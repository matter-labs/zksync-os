//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(non_camel_case_types)]
use crate::error::definitions::APICode;
use crate::error::definitions::Common;
use crate::error::definitions::CommonCode;
use crate::error::definitions::EVMCode;
use crate::error::definitions::EraVM;
use crate::error::definitions::EraVMCode;
use crate::error::definitions::ExecutionPlatform;
use crate::error::definitions::ExecutionPlatformCode;
use crate::error::definitions::FoundryUpstream;
use crate::error::definitions::FoundryUpstreamCode;
use crate::error::definitions::FoundryZksync;
use crate::error::definitions::FoundryZksyncCode;
use crate::error::definitions::HardhatUpstream;
use crate::error::definitions::HardhatUpstreamCode;
use crate::error::definitions::HardhatZksync;
use crate::error::definitions::HardhatZksyncCode;
use crate::error::definitions::LLVM_EVMCode;
use crate::error::definitions::LLVM_Era;
use crate::error::definitions::LLVM_EraCode;
use crate::error::definitions::Native;
use crate::error::definitions::NativeCode;
use crate::error::definitions::Sequencer;
use crate::error::definitions::SequencerCode;
use crate::error::definitions::Solc;
use crate::error::definitions::SolcCode;
use crate::error::definitions::SolcFork;
use crate::error::definitions::SolcForkCode;
use crate::error::definitions::Storage;
use crate::error::definitions::StorageCode;
use crate::error::definitions::System;
use crate::error::definitions::SystemCode;
use crate::error::definitions::SystemEnvironment;
use crate::error::definitions::SystemEnvironmentCode;
use crate::error::definitions::WASMCode;
use crate::error::definitions::Zksolc;
use crate::error::definitions::ZksolcCode;
use crate::error::definitions::Zkvyper;
use crate::error::definitions::ZkvyperCode;
use crate::error::definitions::API;
use crate::error::definitions::EVM;
use crate::error::definitions::LLVM_EVM;
use crate::error::definitions::WASM;
use crate::error::ICustomError;
use crate::error::IUnifiedError;
use crate::kind::Kind;
use core::fmt;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
use strum_macros::IntoStaticStr;
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize, serde::Deserialize))]
pub enum ZksyncError {
    Compiler(Compiler),
    Core(Core),
    ExecutionEnvironment(ExecutionEnvironment),
    Foundry(Foundry),
    Hardhat(Hardhat),
    Os(Os),
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for ZksyncError {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            ZksyncError::Compiler(error) => error.get_documentation(),
            ZksyncError::Core(error) => error.get_documentation(),
            ZksyncError::ExecutionEnvironment(error) => error.get_documentation(),
            ZksyncError::Foundry(error) => error.get_documentation(),
            ZksyncError::Hardhat(error) => error.get_documentation(),
            ZksyncError::Os(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for ZksyncError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ZksyncError::Compiler(domain_error) => domain_error.fmt(f),
            ZksyncError::Core(domain_error) => domain_error.fmt(f),
            ZksyncError::ExecutionEnvironment(domain_error) => domain_error.fmt(f),
            ZksyncError::Foundry(domain_error) => domain_error.fmt(f),
            ZksyncError::Hardhat(domain_error) => domain_error.fmt(f),
            ZksyncError::Os(domain_error) => domain_error.fmt(f),
        }
    }
}
impl ZksyncError {
    pub fn get_kind(&self) -> crate::kind::Kind {
        match self {
            ZksyncError::Compiler(Compiler::LLVM_EVM(_)) => Kind::Compiler(CompilerCode::LLVM_EVM),
            ZksyncError::Compiler(Compiler::LLVM_Era(_)) => Kind::Compiler(CompilerCode::LLVM_Era),
            ZksyncError::Compiler(Compiler::Solc(_)) => Kind::Compiler(CompilerCode::Solc),
            ZksyncError::Compiler(Compiler::SolcFork(_)) => Kind::Compiler(CompilerCode::SolcFork),
            ZksyncError::Compiler(Compiler::Zksolc(_)) => Kind::Compiler(CompilerCode::Zksolc),
            ZksyncError::Compiler(Compiler::Zkvyper(_)) => Kind::Compiler(CompilerCode::Zkvyper),
            ZksyncError::Core(Core::API(_)) => Kind::Core(CoreCode::API),
            ZksyncError::Core(Core::EraVM(_)) => Kind::Core(CoreCode::EraVM),
            ZksyncError::Core(Core::ExecutionPlatform(_)) => {
                Kind::Core(CoreCode::ExecutionPlatform)
            }
            ZksyncError::Core(Core::Sequencer(_)) => Kind::Core(CoreCode::Sequencer),
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::Common(_)) => {
                Kind::ExecutionEnvironment(ExecutionEnvironmentCode::Common)
            }
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::EVM(_)) => {
                Kind::ExecutionEnvironment(ExecutionEnvironmentCode::EVM)
            }
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::Native(_)) => {
                Kind::ExecutionEnvironment(ExecutionEnvironmentCode::Native)
            }
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::WASM(_)) => {
                Kind::ExecutionEnvironment(ExecutionEnvironmentCode::WASM)
            }
            ZksyncError::Foundry(Foundry::FoundryUpstream(_)) => {
                Kind::Foundry(FoundryCode::FoundryUpstream)
            }
            ZksyncError::Foundry(Foundry::FoundryZksync(_)) => {
                Kind::Foundry(FoundryCode::FoundryZksync)
            }
            ZksyncError::Hardhat(Hardhat::HardhatUpstream(_)) => {
                Kind::Hardhat(HardhatCode::HardhatUpstream)
            }
            ZksyncError::Hardhat(Hardhat::HardhatZksync(_)) => {
                Kind::Hardhat(HardhatCode::HardhatZksync)
            }
            ZksyncError::Os(Os::Storage(_)) => Kind::Os(OsCode::Storage),
            ZksyncError::Os(Os::System(_)) => Kind::Os(OsCode::System),
            ZksyncError::Os(Os::SystemEnvironment(_)) => Kind::Os(OsCode::SystemEnvironment),
        }
    }
    pub fn get_code(&self) -> u32 {
        match self {
            ZksyncError::Compiler(Compiler::LLVM_EVM(error)) => {
                Into::<LLVM_EVMCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::LLVM_Era(error)) => {
                Into::<LLVM_EraCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::Solc(error)) => Into::<SolcCode>::into(error) as u32,
            ZksyncError::Compiler(Compiler::SolcFork(error)) => {
                Into::<SolcForkCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::Zksolc(error)) => {
                Into::<ZksolcCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::Zkvyper(error)) => {
                Into::<ZkvyperCode>::into(error) as u32
            }
            ZksyncError::Core(Core::API(error)) => Into::<APICode>::into(error) as u32,
            ZksyncError::Core(Core::EraVM(error)) => Into::<EraVMCode>::into(error) as u32,
            ZksyncError::Core(Core::ExecutionPlatform(error)) => {
                Into::<ExecutionPlatformCode>::into(error) as u32
            }
            ZksyncError::Core(Core::Sequencer(error)) => Into::<SequencerCode>::into(error) as u32,
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::Common(error)) => {
                Into::<CommonCode>::into(error) as u32
            }
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::EVM(error)) => {
                Into::<EVMCode>::into(error) as u32
            }
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::Native(error)) => {
                Into::<NativeCode>::into(error) as u32
            }
            ZksyncError::ExecutionEnvironment(ExecutionEnvironment::WASM(error)) => {
                Into::<WASMCode>::into(error) as u32
            }
            ZksyncError::Foundry(Foundry::FoundryUpstream(error)) => {
                Into::<FoundryUpstreamCode>::into(error) as u32
            }
            ZksyncError::Foundry(Foundry::FoundryZksync(error)) => {
                Into::<FoundryZksyncCode>::into(error) as u32
            }
            ZksyncError::Hardhat(Hardhat::HardhatUpstream(error)) => {
                Into::<HardhatUpstreamCode>::into(error) as u32
            }
            ZksyncError::Hardhat(Hardhat::HardhatZksync(error)) => {
                Into::<HardhatZksyncCode>::into(error) as u32
            }
            ZksyncError::Os(Os::Storage(error)) => Into::<StorageCode>::into(error) as u32,
            ZksyncError::Os(Os::System(error)) => Into::<SystemCode>::into(error) as u32,
            ZksyncError::Os(Os::SystemEnvironment(error)) => {
                Into::<SystemEnvironmentCode>::into(error) as u32
            }
        }
    }
}
impl IUnifiedError<ZksyncError> for ZksyncError {}
impl core::error::Error for ZksyncError {}
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[strum_discriminants(derive(FromRepr))]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(CompilerCode))]
#[cfg_attr(
    feature = "use_serde",
    strum_discriminants(derive(serde::Serialize, serde::Deserialize))
)]
#[strum_discriminants(vis(pub))]
pub enum Compiler {
    LLVM_EVM(LLVM_EVM),
    LLVM_Era(LLVM_Era),
    Solc(Solc),
    SolcFork(SolcFork),
    Zksolc(Zksolc),
    Zkvyper(Zkvyper),
}
impl Compiler {
    pub fn get_name(&self) -> &'static str {
        self.into()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for LLVM_EVM {
    fn to_unified(&self) -> ZksyncError {
        Compiler::LLVM_EVM(self.clone()).to_unified()
    }
}
impl From<LLVM_EVM> for Compiler {
    fn from(val: LLVM_EVM) -> Self {
        Compiler::LLVM_EVM(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for LLVM_Era {
    fn to_unified(&self) -> ZksyncError {
        Compiler::LLVM_Era(self.clone()).to_unified()
    }
}
impl From<LLVM_Era> for Compiler {
    fn from(val: LLVM_Era) -> Self {
        Compiler::LLVM_Era(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Solc {
    fn to_unified(&self) -> ZksyncError {
        Compiler::Solc(self.clone()).to_unified()
    }
}
impl From<Solc> for Compiler {
    fn from(val: Solc) -> Self {
        Compiler::Solc(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for SolcFork {
    fn to_unified(&self) -> ZksyncError {
        Compiler::SolcFork(self.clone()).to_unified()
    }
}
impl From<SolcFork> for Compiler {
    fn from(val: SolcFork) -> Self {
        Compiler::SolcFork(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Zksolc {
    fn to_unified(&self) -> ZksyncError {
        Compiler::Zksolc(self.clone()).to_unified()
    }
}
impl From<Zksolc> for Compiler {
    fn from(val: Zksolc) -> Self {
        Compiler::Zksolc(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Zkvyper {
    fn to_unified(&self) -> ZksyncError {
        Compiler::Zkvyper(self.clone()).to_unified()
    }
}
impl From<Zkvyper> for Compiler {
    fn from(val: Zkvyper) -> Self {
        Compiler::Zkvyper(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Compiler {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Compiler(self.clone())
    }
}
impl From<Compiler> for ZksyncError {
    fn from(value: Compiler) -> Self {
        value.to_unified()
    }
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for Compiler {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Compiler::LLVM_EVM(error) => error.get_documentation(),
            Compiler::LLVM_Era(error) => error.get_documentation(),
            Compiler::Solc(error) => error.get_documentation(),
            Compiler::SolcFork(error) => error.get_documentation(),
            Compiler::Zksolc(error) => error.get_documentation(),
            Compiler::Zkvyper(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for Compiler {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Compiler::LLVM_EVM(component) => component.fmt(f),
            Compiler::LLVM_Era(component) => component.fmt(f),
            Compiler::Solc(component) => component.fmt(f),
            Compiler::SolcFork(component) => component.fmt(f),
            Compiler::Zksolc(component) => component.fmt(f),
            Compiler::Zkvyper(component) => component.fmt(f),
        }
    }
}
impl core::error::Error for Compiler {}
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[strum_discriminants(derive(FromRepr))]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(CoreCode))]
#[cfg_attr(
    feature = "use_serde",
    strum_discriminants(derive(serde::Serialize, serde::Deserialize))
)]
#[strum_discriminants(vis(pub))]
pub enum Core {
    API(API),
    EraVM(EraVM),
    ExecutionPlatform(ExecutionPlatform),
    Sequencer(Sequencer),
}
impl Core {
    pub fn get_name(&self) -> &'static str {
        self.into()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for API {
    fn to_unified(&self) -> ZksyncError {
        Core::API(self.clone()).to_unified()
    }
}
impl From<API> for Core {
    fn from(val: API) -> Self {
        Core::API(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for EraVM {
    fn to_unified(&self) -> ZksyncError {
        Core::EraVM(self.clone()).to_unified()
    }
}
impl From<EraVM> for Core {
    fn from(val: EraVM) -> Self {
        Core::EraVM(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for ExecutionPlatform {
    fn to_unified(&self) -> ZksyncError {
        Core::ExecutionPlatform(self.clone()).to_unified()
    }
}
impl From<ExecutionPlatform> for Core {
    fn from(val: ExecutionPlatform) -> Self {
        Core::ExecutionPlatform(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Sequencer {
    fn to_unified(&self) -> ZksyncError {
        Core::Sequencer(self.clone()).to_unified()
    }
}
impl From<Sequencer> for Core {
    fn from(val: Sequencer) -> Self {
        Core::Sequencer(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Core {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Core(self.clone())
    }
}
impl From<Core> for ZksyncError {
    fn from(value: Core) -> Self {
        value.to_unified()
    }
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for Core {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Core::API(error) => error.get_documentation(),
            Core::EraVM(error) => error.get_documentation(),
            Core::ExecutionPlatform(error) => error.get_documentation(),
            Core::Sequencer(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for Core {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Core::API(component) => component.fmt(f),
            Core::EraVM(component) => component.fmt(f),
            Core::ExecutionPlatform(component) => component.fmt(f),
            Core::Sequencer(component) => component.fmt(f),
        }
    }
}
impl core::error::Error for Core {}
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[strum_discriminants(derive(FromRepr))]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ExecutionEnvironmentCode))]
#[cfg_attr(
    feature = "use_serde",
    strum_discriminants(derive(serde::Serialize, serde::Deserialize))
)]
#[strum_discriminants(vis(pub))]
pub enum ExecutionEnvironment {
    Common(Common),
    EVM(EVM),
    Native(Native),
    WASM(WASM),
}
impl ExecutionEnvironment {
    pub fn get_name(&self) -> &'static str {
        self.into()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Common {
    fn to_unified(&self) -> ZksyncError {
        ExecutionEnvironment::Common(self.clone()).to_unified()
    }
}
impl From<Common> for ExecutionEnvironment {
    fn from(val: Common) -> Self {
        ExecutionEnvironment::Common(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for EVM {
    fn to_unified(&self) -> ZksyncError {
        ExecutionEnvironment::EVM(self.clone()).to_unified()
    }
}
impl From<EVM> for ExecutionEnvironment {
    fn from(val: EVM) -> Self {
        ExecutionEnvironment::EVM(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Native {
    fn to_unified(&self) -> ZksyncError {
        ExecutionEnvironment::Native(self.clone()).to_unified()
    }
}
impl From<Native> for ExecutionEnvironment {
    fn from(val: Native) -> Self {
        ExecutionEnvironment::Native(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for WASM {
    fn to_unified(&self) -> ZksyncError {
        ExecutionEnvironment::WASM(self.clone()).to_unified()
    }
}
impl From<WASM> for ExecutionEnvironment {
    fn from(val: WASM) -> Self {
        ExecutionEnvironment::WASM(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for ExecutionEnvironment {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::ExecutionEnvironment(self.clone())
    }
}
impl From<ExecutionEnvironment> for ZksyncError {
    fn from(value: ExecutionEnvironment) -> Self {
        value.to_unified()
    }
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for ExecutionEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            ExecutionEnvironment::Common(error) => error.get_documentation(),
            ExecutionEnvironment::EVM(error) => error.get_documentation(),
            ExecutionEnvironment::Native(error) => error.get_documentation(),
            ExecutionEnvironment::WASM(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for ExecutionEnvironment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExecutionEnvironment::Common(component) => component.fmt(f),
            ExecutionEnvironment::EVM(component) => component.fmt(f),
            ExecutionEnvironment::Native(component) => component.fmt(f),
            ExecutionEnvironment::WASM(component) => component.fmt(f),
        }
    }
}
impl core::error::Error for ExecutionEnvironment {}
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[strum_discriminants(derive(FromRepr))]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(FoundryCode))]
#[cfg_attr(
    feature = "use_serde",
    strum_discriminants(derive(serde::Serialize, serde::Deserialize))
)]
#[strum_discriminants(vis(pub))]
pub enum Foundry {
    FoundryUpstream(FoundryUpstream),
    FoundryZksync(FoundryZksync),
}
impl Foundry {
    pub fn get_name(&self) -> &'static str {
        self.into()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for FoundryUpstream {
    fn to_unified(&self) -> ZksyncError {
        Foundry::FoundryUpstream(self.clone()).to_unified()
    }
}
impl From<FoundryUpstream> for Foundry {
    fn from(val: FoundryUpstream) -> Self {
        Foundry::FoundryUpstream(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for FoundryZksync {
    fn to_unified(&self) -> ZksyncError {
        Foundry::FoundryZksync(self.clone()).to_unified()
    }
}
impl From<FoundryZksync> for Foundry {
    fn from(val: FoundryZksync) -> Self {
        Foundry::FoundryZksync(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Foundry {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Foundry(self.clone())
    }
}
impl From<Foundry> for ZksyncError {
    fn from(value: Foundry) -> Self {
        value.to_unified()
    }
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for Foundry {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Foundry::FoundryUpstream(error) => error.get_documentation(),
            Foundry::FoundryZksync(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for Foundry {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Foundry::FoundryUpstream(component) => component.fmt(f),
            Foundry::FoundryZksync(component) => component.fmt(f),
        }
    }
}
impl core::error::Error for Foundry {}
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[strum_discriminants(derive(FromRepr))]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(HardhatCode))]
#[cfg_attr(
    feature = "use_serde",
    strum_discriminants(derive(serde::Serialize, serde::Deserialize))
)]
#[strum_discriminants(vis(pub))]
pub enum Hardhat {
    HardhatUpstream(HardhatUpstream),
    HardhatZksync(HardhatZksync),
}
impl Hardhat {
    pub fn get_name(&self) -> &'static str {
        self.into()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for HardhatUpstream {
    fn to_unified(&self) -> ZksyncError {
        Hardhat::HardhatUpstream(self.clone()).to_unified()
    }
}
impl From<HardhatUpstream> for Hardhat {
    fn from(val: HardhatUpstream) -> Self {
        Hardhat::HardhatUpstream(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for HardhatZksync {
    fn to_unified(&self) -> ZksyncError {
        Hardhat::HardhatZksync(self.clone()).to_unified()
    }
}
impl From<HardhatZksync> for Hardhat {
    fn from(val: HardhatZksync) -> Self {
        Hardhat::HardhatZksync(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Hardhat {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Hardhat(self.clone())
    }
}
impl From<Hardhat> for ZksyncError {
    fn from(value: Hardhat) -> Self {
        value.to_unified()
    }
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for Hardhat {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Hardhat::HardhatUpstream(error) => error.get_documentation(),
            Hardhat::HardhatZksync(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for Hardhat {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Hardhat::HardhatUpstream(component) => component.fmt(f),
            Hardhat::HardhatZksync(component) => component.fmt(f),
        }
    }
}
impl core::error::Error for Hardhat {}
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, EnumDiscriminants, Eq, PartialEq)]
#[strum_discriminants(derive(FromRepr))]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(OsCode))]
#[cfg_attr(
    feature = "use_serde",
    strum_discriminants(derive(serde::Serialize, serde::Deserialize))
)]
#[strum_discriminants(vis(pub))]
pub enum Os {
    Storage(Storage),
    System(System),
    SystemEnvironment(SystemEnvironment),
}
impl Os {
    pub fn get_name(&self) -> &'static str {
        self.into()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Storage {
    fn to_unified(&self) -> ZksyncError {
        Os::Storage(self.clone()).to_unified()
    }
}
impl From<Storage> for Os {
    fn from(val: Storage) -> Self {
        Os::Storage(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for System {
    fn to_unified(&self) -> ZksyncError {
        Os::System(self.clone()).to_unified()
    }
}
impl From<System> for Os {
    fn from(val: System) -> Self {
        Os::System(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for SystemEnvironment {
    fn to_unified(&self) -> ZksyncError {
        Os::SystemEnvironment(self.clone()).to_unified()
    }
}
impl From<SystemEnvironment> for Os {
    fn from(val: SystemEnvironment) -> Self {
        Os::SystemEnvironment(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Os {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Os(self.clone())
    }
}
impl From<Os> for ZksyncError {
    fn from(value: Os) -> Self {
        value.to_unified()
    }
}
#[cfg(feature = "runtime_documentation")]
impl crate::documentation::Documented for Os {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Os::Storage(error) => error.get_documentation(),
            Os::System(error) => error.get_documentation(),
            Os::SystemEnvironment(error) => error.get_documentation(),
        }
    }
}
impl fmt::Display for Os {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Os::Storage(component) => component.fmt(f),
            Os::System(component) => component.fmt(f),
            Os::SystemEnvironment(component) => component.fmt(f),
        }
    }
}
impl core::error::Error for Os {}
