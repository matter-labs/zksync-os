//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(unused)]
#![allow(clippy::useless_format)]
#![allow(non_camel_case_types)]
#[cfg(feature = "runtime_documentation")]
use crate::documentation::Documented;
use crate::error::domains::*;
use crate::error::CustomErrorMessage;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use crate::error::NamedError;
#[cfg(not(feature = "std"))]
use alloc::{borrow::ToOwned, boxed::Box, format, string::String, vec::Vec};
use core::fmt;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(AnvilEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilEnvironment {
    #[doc = "# Summary "]
    #[doc = "Invalid command line arguments provided."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "There are missing or invalid command line arguments, or an invalid combination of arguments is provided."]
    InvalidArguments {
        details: String,
        arguments: String,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Failed to start the server and bind it to the requested host and port."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Anvil-zksync starts the server and listens to requests on a specified host and port, 0.0.0.0:8011 by default. They are configurable using `--host` and `--port` command line arguments."]
    #[doc = ""]
    #[doc = "The host and port used by anvil-zksync are also displayed when you start anvil-zksync:"]
    #[doc = ""]
    #[doc = "```text"]
    #[doc = "========================================"]
    #[doc = "Listening on 0.0.0.0:8011"]
    #[doc = "========================================"]
    #[doc = "```"]
    #[doc = ""]
    #[doc = "This error indicates that listening on the specified host and port failed."]
    ServerStartupFailed {
        host_requested: String,
        port_requested: u32,
        details: String,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Unable to access log file."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Anvil-zksync was unable to open log file for writing."]
    #[doc = "By default, the log file is searched for at `./anvil-zksync.log`."]
    #[doc = "You may provide this path explicitly through the CLI argument `--log-file-path`."]
    LogFileAccessFailed {
        log_file_path: String,
        wrapped_error: String,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "Unable to append to log file. Details: {wrapped_error}"]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Anvil-zksync was unable to write logs to the selected file."]
    #[doc = "By default, the log file is searched for at `./anvil-zksync.log`."]
    #[doc = "You may provide this path explicitly through the CLI argument `--log-file-path`."]
    LogFileWriteFailed {
        log_filename: String,
        wrapped_error: String,
    } = 11u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for AnvilEnvironment {}
impl NamedError for AnvilEnvironment {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilEnvironmentCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilEnvironment> for crate::ZksyncError {
    fn from(val: AnvilEnvironment) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for AnvilEnvironment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for AnvilEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for AnvilEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilEnvironment::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<AnvilEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilEnvironment) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<AnvilEnvironment> for crate::serialized::SerializedError {
    fn from(value: AnvilEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilEnvironment {
    fn get_message(&self) -> String {
        match self {
            AnvilEnvironment::InvalidArguments { details, arguments } => {
                format!("[anvil_zksync-env-1] Invalid arguments: {details}.")
            }
            AnvilEnvironment::ServerStartupFailed {
                host_requested,
                port_requested,
                details,
            } => {
                format ! ("[anvil_zksync-env-2] Failed to start server at {host_requested}:{port_requested}: {details}.")
            }
            AnvilEnvironment::LogFileAccessFailed {
                log_file_path,
                wrapped_error,
            } => {
                format ! ("[anvil_zksync-env-10] Unable to access log file: {log_file_path}. Details: {wrapped_error}")
            }
            AnvilEnvironment::LogFileWriteFailed {
                log_filename,
                wrapped_error,
            } => {
                format ! ("[anvil_zksync-env-11] Unable to append more lines to the log file `{log_filename}`: {wrapped_error}")
            }
            AnvilEnvironment::GenericError { message } => {
                format!("[anvil_zksync-env-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(AnvilGenericCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilGeneric {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for AnvilGeneric {}
impl NamedError for AnvilGeneric {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilGenericCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilGeneric> for crate::ZksyncError {
    fn from(val: AnvilGeneric) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for AnvilGeneric {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for AnvilGeneric {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for AnvilGeneric {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilGeneric::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<AnvilGeneric> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilGeneric) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<AnvilGeneric> for crate::serialized::SerializedError {
    fn from(value: AnvilGeneric) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilGeneric {
    fn get_message(&self) -> String {
        match self {
            AnvilGeneric::GenericError { message } => {
                format!("[anvil_zksync-gen-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(AnvilNodeCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilNode {
    #[doc = "# Summary "]
    #[doc = "Transaction execution reverted and gas was burned."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction execution is reverted due to an error in the anvil-zksync virtual machine execution and all gas is burned."]
    #[doc = "This is a wrapper error that contains a more specific error inside it."]
    #[doc = ""]
    #[doc = "The VM may fail for various reasons including:"]
    #[doc = "- Account validation failures (signature issues, nonce mismatches)"]
    #[doc = "- Paymaster-related errors (when testing account abstraction features)"]
    #[doc = "- Gas limit exceedance"]
    #[doc = "- Storage access limitations"]
    #[doc = "- Contract execution failures"]
    #[doc = ""]
    #[doc = "When using anvil-zksync for testing, these failures are valuable signals that help you identify issues with your contracts or transactions before deploying to the real ZKSync network."]
    TransactionHalt {
        inner: Box<Halt>,
        transaction_hash: ruint::aliases::U256,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Transaction validation failed in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction validation is failed and it is not executed."]
    #[doc = "This is a wrapper error that contains a more specific validation error inside it, which provides details about the cause of failure."]
    #[doc = ""]
    #[doc = "The validation may fail for various reasons including:"]
    #[doc = "- Gas limit exceedance"]
    #[doc = "- Invalid gas limit value"]
    #[doc = "- maxFeePerGas exceeding maxPriorityFeePerGas, and so on."]
    #[doc = ""]
    #[doc = "When using anvil-zksync for testing, these errors are valuable signals that help you identify issues with your contracts or transactions before deploying to the real ZKSync network."]
    TransactionValidationFailed {
        inner: Box<TransactionValidation>,
        transaction_hash: ruint::aliases::U256,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "Transaction gas estimation failed in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a gas estimation for transaction failed."]
    #[doc = "This is a wrapper error that contains a more specific gas estimation error inside it, which provides details about the cause of failure."]
    TransactionGasEstimationFailed {
        inner: Box<GasEstimation>,
        transaction_data: Vec<u8>,
    } = 11u32,
    #[doc = "# Summary "]
    #[doc = "Requested block timestamp is earlier than the current timestamp."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when attempting to set a future block timestamp to a value that is earlier than the timestamp of the most recently mined block."]
    #[doc = ""]
    #[doc = "In anvil-zksync, block timestamps must always increase monotonically. This simulates the behavior of real blockchain networks where time only moves forward. Each new block must have a timestamp greater than its predecessor."]
    #[doc = ""]
    #[doc = "Anvil-zksync provides methods to manipulate time for testing purposes (like `evm_increaseTime` and `evm_setNextBlockTimestamp`), but these can only move time forward, never backward."]
    #[doc = ""]
    #[doc = "Block timestamps in anvil-zksync are used by:"]
    #[doc = "- Smart contracts that rely on `block.timestamp` for time-dependent logic"]
    #[doc = "- System contracts that need to track event timing"]
    #[doc = "- Time-locked functionality in DeFi applications and governance protocols"]
    #[doc = ""]
    #[doc = "When testing contracts that have time-dependent logic, it's important to ensure that any manipulated timestamps move forward in time, not backward."]
    TimestampBackwardsError {
        timestamp_requested: u64,
        timestamp_now: u64,
    } = 20u32,
    #[doc = "# Summary "]
    #[doc = "Failed to serialize transaction request into a valid transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when anvil-zksync is unable to convert a transaction request into a properly formatted transaction object."]
    #[doc = "This typically happens during transaction creation or gas estimation when the request contains invalid or incompatible parameters."]
    SerializationError {
        transaction_type: String,
        from: ruint::aliases::U256,
        to: ruint::aliases::U256,
        reason: String,
    } = 30u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for AnvilNode {}
impl NamedError for AnvilNode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilNodeCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilNode> for crate::ZksyncError {
    fn from(val: AnvilNode) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for AnvilNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for AnvilNode {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for AnvilNode {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilNode::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<AnvilNode> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilNode) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<AnvilNode> for crate::serialized::SerializedError {
    fn from(value: AnvilNode) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilNode {
    fn get_message(&self) -> String {
        match self {
            AnvilNode::TransactionHalt {
                inner,
                transaction_hash,
            } => {
                format ! ("[anvil_zksync-node-1] Transaction {transaction_hash} execution reverted and gas was burned:\n{inner}")
            }
            AnvilNode::TransactionValidationFailed {
                inner,
                transaction_hash,
            } => {
                format ! ("[anvil_zksync-node-10] Transaction {transaction_hash}: validation failed:\n{inner}")
            }
            AnvilNode::TransactionGasEstimationFailed {
                inner,
                transaction_data,
            } => {
                format!("[anvil_zksync-node-11] Gas estimation failed:\n{inner}")
            }
            AnvilNode::TimestampBackwardsError {
                timestamp_requested,
                timestamp_now,
            } => {
                format ! ("[anvil_zksync-node-20] Failed to force the next timestamp to value {timestamp_requested}. It should be greater than the last timestamp {timestamp_now}.")
            }
            AnvilNode::SerializationError {
                transaction_type,
                from,
                to,
                reason,
            } => {
                format ! ("[anvil_zksync-node-30] Failed to parse a {transaction_type} transaction from request (from={from}, to={to}): {reason}.")
            }
            AnvilNode::GenericError { message } => {
                format!("[anvil_zksync-node-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(GasEstimationCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum GasEstimation {
    #[doc = "# Summary "]
    #[doc = "Transaction exceeds the limit for published pubdata."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction attempts to publish more pubdata than is allowed in a batch. Each transaction has a limit on how much pubdata it can publish to maintain network efficiency and prevent abuse."]
    ExceedsLimitForPublishedPubdata {
        pubdata_published: u32,
        pubdata_limit: u32,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Transaction gas estimation exceeds the block gas limit."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the total gas required for a transaction exceeds the maximum allowed for a block."]
    #[doc = "The total gas is calculated by summing three components: the gas needed for publishing pubdata, the fixed overhead costs,"]
    #[doc = "and the estimated gas for the transaction body itself. When this sum overflows or exceeds the block limit, this error is thrown."]
    ExceedsBlockGasLimit {
        overhead: u64,
        gas_for_pubdata: u64,
        estimated_body_cost: u64,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Transaction execution reverts and burns all gas while estimating required gas in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when anvil-zksync is trying to estimate gas required to run this transaction "]
    #[doc = "but the estimation fails because the transaction reverts and burns all gas."]
    #[doc = ""]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "If the first run was successful, anvil-zksync proceeds with the estimation"]
    #[doc = "The estimation algorithm looks for a minimum gas value that makes the transaction succeed."]
    #[doc = "This works if the transaction fails for all lower gas values and succeeds for all higher gas values."]
    #[doc = "Some valid, but exotic transactions, resist estimation."]
    #[doc = "Typically they depend on specific gas values, for example, they fail if `gasleft()` returned a value in a specific range."]
    TransactionHalt {
        inner: Box<Halt>,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "Transaction execution reverted while estimating required gas in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when anvil-zksync is trying to estimate gas required to run this transaction "]
    #[doc = "but the estimation fails because the transaction is reverted."]
    #[doc = ""]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "If the first run was successful, anvil-zksync proceeds with the estimation"]
    #[doc = "The estimation algorithm looks for a minimum gas value that makes the transaction succeed."]
    #[doc = "This works if the transaction fails for all lower gas values and succeeds for all higher gas values."]
    #[doc = "Some valid, but exotic transactions, resist estimation."]
    #[doc = "Typically they depend on specific gas values, for example, they revert if `gasleft()` returned a value in a specific range."]
    TransactionRevert {
        inner: Box<Revert>,
        data: Vec<u8>,
    } = 11u32,
    #[doc = "# Summary "]
    #[doc = "An attempt to run the transaction with maximum gas resulted in reverting the transaction and burning all gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "This error occurs when this initial run results in a revert and burns all gas, suggesting that "]
    #[doc = "no amount of gas will make this transaction executable."]
    #[doc = ""]
    #[doc = "There might be valid, but exotic transactions that fail when run with maximum gas provided,"]
    #[doc = "but these are rare. Typically they depend on specific gas values."]
    #[doc = "Usually, this error indicates either an unconditional revert or excessive gas consumption."]
    TransactionAlwaysHalts {
        inner: Box<Halt>,
    } = 20u32,
    #[doc = "# Summary "]
    #[doc = "An attempt to run the transaction with maximum gas resulted in reverting the transaction and returning unspent gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Before estimating gas, anvil-zksync first runs the transaction with maximum gas possible."]
    #[doc = "This error occurs when this initial run results in a revert and returns unspent gas, suggesting that "]
    #[doc = "no amount of gas will make this transaction executable."]
    #[doc = ""]
    #[doc = "There might be valid, but exotic transactions that fail when run with maximum gas provided,"]
    #[doc = "but these are rare. Typically they depend on specific gas values."]
    #[doc = "Usually, this error indicates either an unconditional revert or excessive gas consumption."]
    TransactionAlwaysReverts {
        inner: Box<Revert>,
        data: Vec<u8>,
    } = 21u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for GasEstimation {}
impl NamedError for GasEstimation {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for GasEstimationCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<GasEstimation> for crate::ZksyncError {
    fn from(val: GasEstimation) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for GasEstimation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for GasEstimation {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for GasEstimation {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        GasEstimation::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<GasEstimation> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: GasEstimation) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<GasEstimation> for crate::serialized::SerializedError {
    fn from(value: GasEstimation) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for GasEstimation {
    fn get_message(&self) -> String {
        match self {
            GasEstimation::ExceedsLimitForPublishedPubdata {
                pubdata_published,
                pubdata_limit,
            } => {
                format ! ("[anvil_zksync-gas_estim-1] Transaction has published {pubdata_published} bytes which exceeds limit for published pubdata ({pubdata_limit}).")
            }
            GasEstimation::ExceedsBlockGasLimit {
                overhead,
                gas_for_pubdata,
                estimated_body_cost,
            } => {
                format ! ("[anvil_zksync-gas_estim-2] Estimating full gas limit overflows while adding up additional gas ({gas_for_pubdata}), overhead ({overhead}), and estimated transaction body gas cost ({estimated_body_cost}).")
            }
            GasEstimation::TransactionHalt { inner } => {
                format ! ("[anvil_zksync-gas_estim-10] Gas estimation failed because the transaction exhibits exotic gas behavior and reverts, burning all gas: {inner}")
            }
            GasEstimation::TransactionRevert { inner, data } => {
                format ! ("[anvil_zksync-gas_estim-11] Gas estimation failed because the transaction exhibits exotic gas behavior and reverts, returning unspent gas: {inner}")
            }
            GasEstimation::TransactionAlwaysHalts { inner } => {
                format ! ("[anvil_zksync-gas_estim-20] Gas estimation is impossible because the transaction can not be executed with maximum gas, it reverts and returns unspent gas:\n{inner}")
            }
            GasEstimation::TransactionAlwaysReverts { inner, data } => {
                format ! ("[anvil_zksync-gas_estim-21] Gas estimation is impossible because the transaction can not be executed with maximum gas, it reverts and burns all gas:\n{inner}")
            }
            GasEstimation::GenericError { message } => {
                format!("[anvil_zksync-gas_estim-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(HaltCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Halt {
    #[doc = "# Summary "]
    #[doc = "Account validation failed during execution."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the account validation step fails during the verification and execution of a transaction."]
    ValidationFailed {
        msg: String,
        data: String,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Paymaster validation failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the paymaster validation process fails during transaction execution."]
    PaymasterValidationFailed {
        msg: String,
        data: String,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Pre-paymaster preparation step failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs during pre-transaction paymaster preparation if the paymaster input is too short (less than 4 bytes) or its selector is unsupported."]
    PrePaymasterPreparationFailed {
        msg: String,
        data: String,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = "Payment for the transaction failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the system fails to deduct the required fees for executing the transaction."]
    PayForTxFailed {
        msg: String,
        data: String,
    } = 4u32,
    #[doc = "# Summary "]
    #[doc = "Failed to register factory dependencies for L1 transactions."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the system is unable to mark the factory dependencies for an L1 transaction in the known code storage. For L1 transactions, factory dependencies must be recorded as known to ensure that all required code components are available. A failure here may indicate that the dependency data is missing or malformed."]
    FailedToMarkFactoryDependencies {
        msg: String,
        data: String,
    } = 5u32,
    #[doc = "# Summary "]
    #[doc = "Transaction fee deduction failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is raised when the funds transferred to the bootloader are insufficient compared to the required fee (calculated as gasLimit * gasPrice). This may occur when the payer (account or paymaster) does not send enough ETH or when fee parameters are misconfigured."]
    FailedToChargeFee {
        msg: String,
        data: String,
    } = 6u32,
    #[doc = "# Summary "]
    #[doc = "The sender address is not a valid account."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction is attempted from an address that has not been deployed as an account, meaning the `from` address is just a contract."]
    FromIsNotAnAccount = 7u32,
    #[doc = "# Summary "]
    #[doc = "An inner transaction error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Transaction reverted due to a contract call that failed during execution."]
    InnerTxError = 8u32,
    #[doc = "# Summary "]
    #[doc = "An unknown error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the system encounters an unspecified reason for reverting and burning all gas."]
    Unknown {
        msg: String,
        data: String,
    } = 9u32,
    #[doc = "# Summary "]
    #[doc = "The bootloader encountered an unexpected state."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error can be triggered by various bootloader anomalies such as mismatched fee parameters (e.g., baseFee greater than maxFeePerGas), unaccepted pubdata price, failed system calls (like L1 messenger or System Context), or internal assertion failures."]
    UnexpectedVMBehavior {
        problem: String,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "The bootloader has run out of gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the bootloader does not have enough gas to continue executing the transaction."]
    BootloaderOutOfGas = 11u32,
    #[doc = "# Summary "]
    #[doc = "The validation step ran out of gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Validation step of transaction execution exceeds the allocated gas limit."]
    ValidationOutOfGas = 12u32,
    #[doc = "# Summary "]
    #[doc = "The transaction's gas limit is excessively high."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the gas limit set for the transaction is too large for the server to handle."]
    TooBigGasLimit = 13u32,
    #[doc = "# Summary "]
    #[doc = "Insufficient gas for the bootloader to continue the transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The bootloader checks if it can supply the requested gas plus overhead. If the remaining gas is below this threshold, it reverts."]
    NotEnoughGasProvided = 14u32,
    #[doc = "# Summary "]
    #[doc = "The transaction exceeded the allowed number of storage invocations."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the transaction makes too many missing invocations to memory, surpassing the allowed limit."]
    MissingInvocationLimitReached = 15u32,
    #[doc = "# Summary "]
    #[doc = "Unable to set L2 block information."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "System failed to set the necessary information for the L2 block during execution."]
    FailedToSetL2Block {
        msg: String,
    } = 16u32,
    #[doc = "# Summary "]
    #[doc = "Unable to append the transaction hash to the ongoing L2 block."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The system context call to record this transaction in the current L2 block failed."]
    FailedToAppendTransactionToL2Block {
        msg: String,
    } = 17u32,
    #[doc = "# Summary "]
    #[doc = "The virtual machine encountered a panic."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "VM experiences a critical failure and panic during transaction execution."]
    VMPanic = 18u32,
    #[doc = "# Summary "]
    #[doc = "Tracer aborted the transaction execution."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Custom tracer used during transaction execution decides to abort the process, typically due to specific conditions being met."]
    TracerCustom {
        msg: String,
    } = 19u32,
    #[doc = "# Summary "]
    #[doc = "Unable to publish compressed bytecodes."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Emitted when the system fails to publish the compressed bytecodes during execution."]
    FailedToPublishCompressedBytecodes = 20u32,
    #[doc = "# Summary "]
    #[doc = "Block timestamp assertion failed during the transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error often occurs if the transaction's timestamp is behind the last known block or conflicts with expected chronological order."]
    FailedBlockTimestampAssertion = 21u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for Halt {}
impl NamedError for Halt {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HaltCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Halt> for crate::ZksyncError {
    fn from(val: Halt) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Halt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Halt {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Halt {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Halt::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Halt> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Halt) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Halt> for crate::serialized::SerializedError {
    fn from(value: Halt) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Halt {
    fn get_message(&self) -> String {
        match self {
            Halt::ValidationFailed { msg, data } => {
                format!("[anvil_zksync-halt-1] Account validation error: {msg}: {data}")
            }
            Halt::PaymasterValidationFailed { msg, data } => {
                format!("[anvil_zksync-halt-2] Paymaster validation error: {msg}: {data}.")
            }
            Halt::PrePaymasterPreparationFailed { msg, data } => {
                format!("[anvil_zksync-halt-3] Pre-paymaster preparation error: {msg}: {data}")
            }
            Halt::PayForTxFailed { msg, data } => {
                format!("[anvil_zksync-halt-4] Failed to pay for the transaction: {msg}: {data}")
            }
            Halt::FailedToMarkFactoryDependencies { msg, data } => {
                format!("[anvil_zksync-halt-5] Failed to mark factory dependencies: {msg}: {data}")
            }
            Halt::FailedToChargeFee { msg, data } => {
                format!("[anvil_zksync-halt-6] Failed to charge fee: {msg}: {data}")
            }
            Halt::FromIsNotAnAccount => {
                format!("[anvil_zksync-halt-7] Sender is not an account")
            }
            Halt::InnerTxError => {
                format!("[anvil_zksync-halt-8] Bootloader-based tx failed")
            }
            Halt::Unknown { msg, data } => {
                format!("[anvil_zksync-halt-9] Unknown reason: {msg}: {data}")
            }
            Halt::UnexpectedVMBehavior { problem } => {
                format ! ("[anvil_zksync-halt-10] Virtual machine entered unexpected state. Error description: {problem}")
            }
            Halt::BootloaderOutOfGas => {
                format!("[anvil_zksync-halt-11] Bootloader out of gas")
            }
            Halt::ValidationOutOfGas => {
                format!("[anvil_zksync-halt-12] Validation run out of gas")
            }
            Halt::TooBigGasLimit => {
                format ! ("[anvil_zksync-halt-13] Transaction has a too big ergs limit and will not be executed by the server")
            }
            Halt::NotEnoughGasProvided => {
                format ! ("[anvil_zksync-halt-14] Bootloader does not have enough gas to proceed with the transaction.")
            }
            Halt::MissingInvocationLimitReached => {
                format!("[anvil_zksync-halt-15] Transaction produced too much storage accesses.")
            }
            Halt::FailedToSetL2Block { msg } => {
                format!(
                    "[anvil_zksync-halt-16] Failed to set information about the L2 block: {msg}"
                )
            }
            Halt::FailedToAppendTransactionToL2Block { msg } => {
                format ! ("[anvil_zksync-halt-17] Failed to append the transaction to the current L2 block: {msg}")
            }
            Halt::VMPanic => {
                format!("[anvil_zksync-halt-18] VM panicked")
            }
            Halt::TracerCustom { msg } => {
                format!("[anvil_zksync-halt-19] Tracer aborted execution: {msg}")
            }
            Halt::FailedToPublishCompressedBytecodes => {
                format!("[anvil_zksync-halt-20] Failed to publish compressed bytecodes")
            }
            Halt::FailedBlockTimestampAssertion => {
                format!("[anvil_zksync-halt-21] Transaction failed `block.timestamp` assertion")
            }
            Halt::GenericError { message } => {
                format!("[anvil_zksync-halt-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(RevertCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Revert {
    #[doc = "# Summary "]
    #[doc = "Execution reverted due to a failure."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error indicates that the transaction execution was reverted."]
    General {
        msg: String,
        data: Vec<u8>,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "An inner transaction error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when an inner transaction within the VM fails, typically related to bootloader execution."]
    InnerTxError = 2u32,
    #[doc = "# Summary "]
    #[doc = "A generic VM error."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error indicates a generic failure within the VM, without specific details."]
    VmError = 3u32,
    #[doc = "# Summary "]
    #[doc = "An unknown VM revert reason was encountered."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the VM encounters a revert reason that is not recognized."]
    #[doc = "In most cases, this error may also indicate that the transaction exhausted all the gas allocated for its execution."]
    Unknown {
        function_selector: String,
        data: String,
    } = 4u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for Revert {}
impl NamedError for Revert {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for RevertCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Revert> for crate::ZksyncError {
    fn from(val: Revert) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Revert {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Revert {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Revert {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Revert::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Revert> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Revert) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Revert> for crate::serialized::SerializedError {
    fn from(value: Revert) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Revert {
    fn get_message(&self) -> String {
        match self {
            Revert::General { msg, data } => {
                format!("[anvil_zksync-revert-1] Execution reverted with message: {msg}")
            }
            Revert::InnerTxError => {
                format!("[anvil_zksync-revert-2] Bootloader-based transaction failed.")
            }
            Revert::VmError => {
                format!("[anvil_zksync-revert-3] VM Error")
            }
            Revert::Unknown {
                function_selector,
                data,
            } => {
                format ! ("[anvil_zksync-revert-4] Unknown VM revert reason: function_selector={function_selector}, data={data}")
            }
            Revert::GenericError { message } => {
                format!("[anvil_zksync-revert-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(StateLoaderCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum StateLoader {
    #[doc = "# Summary "]
    #[doc = "It is not allowed to load a state overriding the existing node state."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "It is not allowed to load a state overriding the existing node state. If you have a use case for that, please create an issue."]
    LoadingStateOverExistingState = 1u32,
    #[doc = "# Summary "]
    #[doc = "Attempt to load a state with no blocks"]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "It is not allowed to load a state without any blocks in it."]
    LoadEmptyState = 2u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Failed to decompress the state."]
    StateDecompression {
        details: String,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Failed to deserialize the state file."]
    StateDeserialization {
        details: String,
    } = 4u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The version of the state file is not recognized."]
    UnknownStateVersion {
        version: u32,
    } = 5u32,
    #[doc = "# Summary "]
    #[doc = ""]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Failed to access the state file."]
    StateFileAccess {
        path: String,
        reason: String,
    } = 6u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for StateLoader {}
impl NamedError for StateLoader {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for StateLoaderCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<StateLoader> for crate::ZksyncError {
    fn from(val: StateLoader) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for StateLoader {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for StateLoader {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for StateLoader {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        StateLoader::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<StateLoader> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: StateLoader) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<StateLoader> for crate::serialized::SerializedError {
    fn from(value: StateLoader) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for StateLoader {
    fn get_message(&self) -> String {
        match self {
            StateLoader::LoadingStateOverExistingState => {
                format ! ("[anvil_zksync-state-1] Loading state into a node with existing state is not allowed.")
            }
            StateLoader::LoadEmptyState => {
                format!("[anvil_zksync-state-2] Loading a state without blocks is not allowed.")
            }
            StateLoader::StateDecompression { details } => {
                format!("[anvil_zksync-state-3] Failed to decompress state: {details}.")
            }
            StateLoader::StateDeserialization { details } => {
                format!("[anvil_zksync-state-4] Failed to deserialize state: {details}")
            }
            StateLoader::UnknownStateVersion { version } => {
                format!("[anvil_zksync-state-5] Unknown version of the state: {version}.")
            }
            StateLoader::StateFileAccess { path, reason } => {
                format ! ("[anvil_zksync-state-6] Error while accessing the state located at `{path}`: {reason}.")
            }
            StateLoader::GenericError { message } => {
                format!("[anvil_zksync-state-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(TransactionValidationCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum TransactionValidation {
    #[doc = "# Summary "]
    #[doc = "Transaction validation failed due to excessive gas limit -- did you provide invalid gas limit?"]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction's gas limit exceeds the maximum allowed gas allowed by ZKsync protocol."]
    #[doc = "As of protocol version 27, the gas is limited to 2^50"]
    #[doc = "Note: When anvil-zksync is in forking mode, it lock-in and uses gas price at the forked block"]
    InvalidGasLimit {
        tx_gas_limit: ruint::aliases::U256,
        max_gas: ruint::aliases::U256,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Transaction validation failed due to excessive gas per pubdata limit."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction's gas per pubdata limit exceeds the maximum allowed gas allowed by ZKsync protocol."]
    #[doc = "As of protocol version 27, the gas is limited to 2^50"]
    #[doc = "Note: When anvil-zksync is in forking mode, it lock-in and uses gas price at the forked block"]
    GasPerPubdataLimit {
        tx_gas_per_pubdata_limit: ruint::aliases::U256,
        max_gas: ruint::aliases::U256,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Transaction's maxFeePerGas is lower than the current gas price in anvil-zksync."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the maximum fee per gas specified in the transaction is lower than the current gas price set in the anvil-zksync node."]
    #[doc = "To be considered valid, transactions must specify a maxFeePerGas that is greater or equal to the current gas price"]
    #[doc = ""]
    #[doc = "In anvil-zksync, the gas price can be configured when starting the node using `--l1-gas-price` argument or can be modified dynamically. By default, the node simulates a gas price model similar to the real ZKSync network, including:"]
    #[doc = "1. A base computation fee (similar to Ethereum's base fee)"]
    #[doc = "2. A simulated pubdata posting fee"]
    #[doc = ""]
    #[doc = "Even though anvil-zksync is a testing environment, it enforces these gas price validations to ensure that your tests accurately reflect how transactions would behave on the actual ZKSync network."]
    #[doc = "Note: When anvil-zksync is in forking mode, it lock-in and uses gas price at the forked block"]
    MaxFeePerGasTooLow {
        max_fee_per_gas: ruint::aliases::U256,
        l2_gas_price: ruint::aliases::U256,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = "Transaction's maxPriorityFeePerGas exceeds maxFeePerGas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction's maximum priority fee per gas is greater than its maximum fee per gas in anvil-zksync."]
    #[doc = "In ZKSync, the field `maxPriorityFeePerGas` is ignored, as ZKsync doesn’t have a concept of priority fees."]
    #[doc = "Instead, `maxFeePerGas` is utilized and includes the base fees."]
    #[doc = "However, certain transaction types like EIP-1559 or EIP-712 may contain field `maxPriorityFeePerGas`, which should be less or equal to the field `maxFeePerGas`."]
    MaxPriorityFeeGreaterThanMaxFee {
        max_fee_per_gas: ruint::aliases::U256,
        max_priority_fee_per_gas: ruint::aliases::U256,
    } = 4u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for TransactionValidation {}
impl NamedError for TransactionValidation {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for TransactionValidationCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<TransactionValidation> for crate::ZksyncError {
    fn from(val: TransactionValidation) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for TransactionValidation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for TransactionValidation {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for TransactionValidation {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        TransactionValidation::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<TransactionValidation>
    for crate::packed::PackedError<crate::error::domains::ZksyncError>
{
    fn from(value: TransactionValidation) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<TransactionValidation> for crate::serialized::SerializedError {
    fn from(value: TransactionValidation) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for TransactionValidation {
    fn get_message(&self) -> String {
        match self {
            TransactionValidation::InvalidGasLimit {
                tx_gas_limit,
                max_gas,
            } => {
                format ! ("[anvil_zksync-tx_invalid-1] Gas limit for transaction is {tx_gas_limit} which exceeds maximum allowed gas {max_gas}")
            }
            TransactionValidation::GasPerPubdataLimit {
                tx_gas_per_pubdata_limit,
                max_gas,
            } => {
                format ! ("[anvil_zksync-tx_invalid-2] Gas per pubdata limit is {tx_gas_per_pubdata_limit} which exceeds maximum allowed gas {max_gas}")
            }
            TransactionValidation::MaxFeePerGasTooLow {
                max_fee_per_gas,
                l2_gas_price,
            } => {
                format ! ("[anvil_zksync-tx_invalid-3] Max fee per gas: {max_fee_per_gas}, current L2 gas price {l2_gas_price} is too expensive.")
            }
            TransactionValidation::MaxPriorityFeeGreaterThanMaxFee {
                max_fee_per_gas,
                max_priority_fee_per_gas,
            } => {
                format ! ("[anvil_zksync-tx_invalid-4] maxPriorityFeePerGas={max_priority_fee_per_gas} exceeds the limit value maxFeePerGas={max_fee_per_gas}")
            }
            TransactionValidation::GenericError { message } => {
                format!("[anvil_zksync-tx_invalid-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for Ethereum VM (EVM)."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for LLVM_EVM {}
impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for LLVM_EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_EVM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_EVM {
    fn get_message(&self) -> String {
        match self {
            LLVM_EVM::GenericError { message } => {
                format!("[compiler-llvm+evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for LLVM_Era {}
impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for LLVM_Era {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_Era::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_Era {
    fn get_message(&self) -> String {
        match self {
            LLVM_Era::GenericError { message } => {
                format!("[compiler-llvm+era-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the official Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Solc {}
impl NamedError for Solc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Solc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Solc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Solc::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Solc {
    fn get_message(&self) -> String {
        match self {
            Solc::GenericError { message } => {
                format!("[compiler-solc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync fork of Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for SolcFork {}
impl NamedError for SolcFork {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for SolcFork {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for SolcFork {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SolcFork::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for SolcFork {
    fn get_message(&self) -> String {
        match self {
            SolcFork::GenericError { message } => {
                format!("[compiler-solc+fork-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Solidity compiler for EraVM and EVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Zksolc {}
impl NamedError for Zksolc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Zksolc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Zksolc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zksolc::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zksolc {
    fn get_message(&self) -> String {
        match self {
            Zksolc::GenericError { message } => {
                format!("[compiler-zksolc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Vyper compiler for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Zkvyper {}
impl NamedError for Zkvyper {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Zkvyper {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zkvyper::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zkvyper {
    fn get_message(&self) -> String {
        match self {
            Zkvyper::GenericError { message } => {
                format!("[compiler-zkvyper-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the web3 API."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum API {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for API {}
impl NamedError for API {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for API {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for API {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        API::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for API {
    fn get_message(&self) -> String {
        match self {
            API::GenericError { message } => {
                format!("[core-api-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in EraVM virtual machine executing contracts."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for EraVM {}
impl NamedError for EraVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for EraVM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for EraVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EraVM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for EraVM {
    fn get_message(&self) -> String {
        match self {
            EraVM::GenericError { message } => {
                format!("[core-eravm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the contract execution environment, bootloader, etc."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for ExecutionPlatform {}
impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for ExecutionPlatform {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        ExecutionPlatform::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for ExecutionPlatform {
    fn get_message(&self) -> String {
        match self {
            ExecutionPlatform::GenericError { message } => {
                format!("[core-exec-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the sequencer node"]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
    GenericSequencerError { message: String } = 1u32,
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Sequencer {}
impl NamedError for Sequencer {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Sequencer {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Sequencer {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Sequencer::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Sequencer {
    fn get_message(&self) -> String {
        match self {
            Sequencer::GenericSequencerError { message } => {
                format!("[core-seq-1] Generic error: {message}")
            }
            Sequencer::GenericError { message } => {
                format!("[core-seq-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ValidationCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Validation {
    #[doc = "# Summary "]
    #[doc = "Failed to decode."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The raw transaction data could not be parsed or decoded correctly."]
    InvalidEncoding = 101u32,
    #[doc = "# Summary "]
    #[doc = "Fields set incorrectly in accordance to its type."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The transaction's structure is invalid for its declared type (e.g., Legacy, EIP-2930, EIP-1559)."]
    InvalidStructure = 102u32,
    #[doc = "# Summary "]
    #[doc = "Provided `gas_priority_fee` exceeds the total `gas_max_fee`."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "In an EIP-1559 transaction, the `max_priority_fee_per_gas` (tip) cannot be greater than the `max_fee_per_gas`."]
    PriorityFeeGreaterThanMaxFee = 103u32,
    #[doc = "# Summary "]
    #[doc = "`basefee` is greater than provided `gas_max_fee`."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The `max_fee_per_gas` in an EIP-1559 transaction must be at least as high as the current block's `basefee`."]
    BaseFeeGreaterThanMaxFee = 104u32,
    #[doc = "# Summary "]
    #[doc = "EIP-1559: `gas_price` is less than `basefee`."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "For legacy transactions processed in an EIP-1559 context, their `gas_price` must be at least as high as the block's `basefee`."]
    GasPriceLessThanBasefee = 105u32,
    #[doc = "# Summary "]
    #[doc = "`gas_limit` in the tx is bigger than `block_gas_limit`."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "A transaction cannot require more gas than the total gas available in a single block."]
    CallerGasLimitMoreThanBlock {
        tx_gas_limit: u64,
        block_gas_limit: u64,
    } = 106u32,
    #[doc = "# Summary "]
    #[doc = "Initial gas for a Call is bigger than `gas_limit`."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The base cost to execute the transaction (calculated from its data size, access list, etc.) exceeds the `gas_limit` set in the transaction."]
    CallGasCostMoreThanGasLimit = 107u32,
    #[doc = "# Summary "]
    #[doc = "EIP-3607 Reject transactions from senders with deployed code."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "To prevent certain security risks, accounts with deployed code are not allowed to initiate transactions."]
    RejectCallerWithCode = 108u32,
    #[doc = "# Summary "]
    #[doc = "Transaction account does not have enough amount of ether to cover transferred value and gas_limit*gas_price."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The sender's balance is lower than the transaction's value plus the maximum potential gas fee (`gas_limit` * `max_fee_per_gas`)."]
    LackOfFundForMaxFee {
        fee: ruint::aliases::U256,
        balance: ruint::aliases::U256,
    } = 109u32,
    #[doc = "# Summary "]
    #[doc = "Overflow payment in transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The calculation of the total required funds for the transaction resulted in a value that exceeds the maximum representable amount."]
    OverflowPaymentInTransaction = 110u32,
    #[doc = "# Summary "]
    #[doc = "Nonce overflows in transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The nonce specified in the transaction exceeds the maximum value for a u64."]
    NonceOverflowInTransaction = 111u32,
    #[doc = "# Summary "]
    #[doc = "The transaction nonce is higher than the sender's current nonce."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Transaction nonces must be sequential. This error indicates a future nonce was used, leaving a gap."]
    NonceTooHigh {
        tx: u64,
        state: u64,
    } = 112u32,
    #[doc = "# Summary "]
    #[doc = "The transaction nonce is lower than the sender's current nonce."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This nonce has already been used by a previously confirmed transaction from the same sender."]
    NonceTooLow {
        tx: u64,
        state: u64,
    } = 113u32,
    #[doc = "# Summary "]
    #[doc = "The transaction signature is malleable."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The signature does not conform to standards that prevent malleability (e.g., low-s values as required by EIP-2)."]
    MalleableSignature = 114u32,
    #[doc = "# Summary "]
    #[doc = "The address recovered from the signature does not match the sender."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The public key recovered from the transaction's signature does not correspond to the address listed in the 'from' field."]
    IncorrectFrom {
        tx: ruint::aliases::U160,
        recovered: ruint::aliases::U160,
    } = 115u32,
    #[doc = "# Summary "]
    #[doc = "EIP-3860: Limit and meter initcode."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The size of the initialization code for a contract creation transaction is larger than the maximum allowed by EIP-3860."]
    CreateInitCodeSizeLimit = 116u32,
    #[doc = "# Summary "]
    #[doc = "Transaction chain id does not match the config chain id."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The transaction is signed for a different chain and is therefore invalid on this one. This is a replay protection mechanism."]
    InvalidChainId = 117u32,
    #[doc = "# Summary "]
    #[doc = "Access list is not supported for blocks before the Berlin hardfork."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Access lists were introduced in EIP-2930 as part of the Berlin hardfork. This transaction type is invalid on earlier chain states."]
    AccessListNotSupported = 118u32,
    #[doc = "# Summary "]
    #[doc = "The account's validation method reverted."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The primary `validateTransaction` logic of the smart contract account reverted during execution."]
    AARevertAccountValidate = 119u32,
    #[doc = "# Summary "]
    #[doc = "The account's `payForTransaction` method reverted."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The account's method for paying transaction fees reverted, indicating an issue with its internal fee logic."]
    AARevertAccountPayForTransaction = 120u32,
    #[doc = "# Summary "]
    #[doc = "The account's `prePaymaster` method reverted."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The account's hook that runs before paymaster interaction has reverted."]
    AARevertAccountPrePaymaster = 121u32,
    #[doc = "# Summary "]
    #[doc = "The paymaster's `validateAndPay` method reverted."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The paymaster contract reverted during its validation and payment logic, refusing to sponsor the transaction."]
    AARevertPaymasterValidateAndPay = 122u32,
    #[doc = "# Summary "]
    #[doc = "Bootloader received insufficient fees."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The fees sent with the transaction were not enough to cover the costs required by the bootloader for Account Abstraction."]
    AAReceivedInsufficientFees {
        received: ruint::aliases::U256,
        required: ruint::aliases::U256,
    } = 123u32,
    InvalidMagic = 124u32,
    InvalidReturndataLength = 125u32,
    #[doc = "# Summary "]
    #[doc = "Ran out of gas during validation."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The gas supplied for the validation phase of the Account Abstraction process was insufficient."]
    OutOfGasDuringValidation = 126u32,
    #[doc = "# Summary "]
    #[doc = "Ran out of native resources during validation."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The validation process consumed more native resources (e.g., memory) than allocated."]
    OutOfNativeResourcesDuringValidation = 127u32,
    #[doc = "# Summary "]
    #[doc = "Transaction nonce already used."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The nonce for the Account Abstraction transaction has already been used and is not valid."]
    NonceUsedAlready = 128u32,
    #[doc = "# Summary "]
    #[doc = "Nonce not increased after validation."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "A successful validation is expected to increment the account's nonce, which did not happen."]
    NonceNotIncreased = 129u32,
    #[doc = "# Summary "]
    #[doc = "Return data from paymaster is too short."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The data returned from the paymaster contract did not meet the minimum required length."]
    AAPaymasterReturnDataTooShort = 130u32,
    #[doc = "# Summary "]
    #[doc = "Invalid magic in paymaster validation."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The paymaster contract returned an invalid magic value, failing the validation."]
    AAPaymasterInvalidMagic = 131u32,
    #[doc = "# Summary "]
    #[doc = "Paymaster returned invalid context."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The context returned by the paymaster is invalid or malformed."]
    AAPaymasterContextInvalid = 132u32,
    #[doc = "# Summary "]
    #[doc = "Paymaster context offset is greater than returndata length."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The offset for the context data specified by the paymaster points beyond the bounds of the returned data."]
    AAPaymasterContextOffsetTooLong = 133u32,
    #[doc = "# Summary "]
    #[doc = "Unacceptable gas per pubdata price."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "In L2 systems, this indicates the price for posting data to the L1 is above the limit set by the transaction."]
    GasPerPubdataTooHigh = 134u32,
    #[doc = "# Summary "]
    #[doc = "Block gas limit is too high."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error typically relates to an internal configuration or a special transaction that attempts to set the block gas limit to an invalid value."]
    BlockGasLimitTooHigh = 135u32,
    #[doc = "# Summary "]
    #[doc = "Protocol upgrade tx should be first in the block."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Transactions that trigger a protocol upgrade are required to be the first transaction in their respective blocks."]
    UpgradeTxNotFirst = 136u32,
    UpgradeTxFailed = 137u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl core::error::Error for Validation {}
impl NamedError for Validation {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ValidationCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Validation> for crate::ZksyncError {
    fn from(val: Validation) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Validation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Validation {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Validation {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Validation::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Validation> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Validation) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Validation> for crate::serialized::SerializedError {
    fn from(value: Validation) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Validation {
    fn get_message(&self) -> String {
        match self {
            Validation::InvalidEncoding => {
                format!("[core-tx_valid-101] Failed to decode the transaction.")
            }
            Validation::InvalidStructure => {
                format!("[core-tx_valid-102] Transaction fields are set incorrectly for its type.")
            }
            Validation::PriorityFeeGreaterThanMaxFee => {
                format!("[core-tx_valid-103] The priority fee is greater than the max fee.")
            }
            Validation::BaseFeeGreaterThanMaxFee => {
                format ! ("[core-tx_valid-104] The block's base fee is greater than the transaction's max fee.")
            }
            Validation::GasPriceLessThanBasefee => {
                format!("[core-tx_valid-105] Gas price is less than the block's base fee.")
            }
            Validation::CallerGasLimitMoreThanBlock {
                tx_gas_limit,
                block_gas_limit,
            } => {
                format ! ("[core-tx_valid-106] The transaction's gas limit {tx_gas_limit} exceeds the block's gas limit {block_gas_limit}.")
            }
            Validation::CallGasCostMoreThanGasLimit => {
                format ! ("[core-tx_valid-107] The intrinsic gas cost of the transaction is higher than its gas limit.")
            }
            Validation::RejectCallerWithCode => {
                format ! ("[core-tx_valid-108] The sender account is a contract and cannot initiate transactions.")
            }
            Validation::LackOfFundForMaxFee { fee, balance } => {
                format ! ("[core-tx_valid-109] Sender account has insufficient funds to cover the transaction's maximum cost. Balance: {balance}, Required: {fee}")
            }
            Validation::OverflowPaymentInTransaction => {
                format ! ("[core-tx_valid-110] An arithmetic overflow occurred calculating the transaction's payment.")
            }
            Validation::NonceOverflowInTransaction => {
                format!("[core-tx_valid-111] The transaction's nonce has overflowed.")
            }
            Validation::NonceTooHigh { tx, state } => {
                format!(
                    "[core-tx_valid-112] Transaction nonce {tx} is too high. Expected: {state}."
                )
            }
            Validation::NonceTooLow { tx, state } => {
                format!("[core-tx_valid-113] Transaction nonce {tx} is too low. Expected: {state}.")
            }
            Validation::MalleableSignature => {
                format!("[core-tx_valid-114] The transaction signature is malleable.")
            }
            Validation::IncorrectFrom { tx, recovered } => {
                format ! ("[core-tx_valid-115] The recovered sender address {recovered} does not match the transaction's 'from' address {tx}.")
            }
            Validation::CreateInitCodeSizeLimit => {
                format!(
                    "[core-tx_valid-116] The contract creation initcode exceeds the size limit."
                )
            }
            Validation::InvalidChainId => {
                format ! ("[core-tx_valid-117] The transaction's chain ID does not match the node's chain ID.")
            }
            Validation::AccessListNotSupported => {
                format ! ("[core-tx_valid-118] The transaction includes an access list, which is not supported before the Berlin hardfork.")
            }
            Validation::AARevertAccountValidate => {
                format!("[core-tx_valid-119] Account validation call reverted")
            }
            Validation::AARevertAccountPayForTransaction => {
                format!("[core-tx_valid-120] Account `payForTransaction` call reverted.")
            }
            Validation::AARevertAccountPrePaymaster => {
                format!("[core-tx_valid-121] Account `prePaymaster` call reverted.")
            }
            Validation::AARevertPaymasterValidateAndPay => {
                format!("[core-tx_valid-122] Paymaster `validateAndPay` call reverted.")
            }
            Validation::AAReceivedInsufficientFees { received, required } => {
                format ! ("[core-tx_valid-123] Bootloader received insufficient fees. Received: {received}, Required: {required}.")
            }
            Validation::InvalidMagic => {
                format!("[core-tx_valid-124] Invalid magic value returned by validation.")
            }
            Validation::InvalidReturndataLength => {
                format!("[core-tx_valid-125] Validation returndata is of invalid length.")
            }
            Validation::OutOfGasDuringValidation => {
                format!("[core-tx_valid-126] Ran out of gas during AA validation.")
            }
            Validation::OutOfNativeResourcesDuringValidation => {
                format!("[core-tx_valid-127] Ran out of native resources during validation.")
            }
            Validation::NonceUsedAlready => {
                format!("[core-tx_valid-128] Transaction nonce already used.")
            }
            Validation::NonceNotIncreased => {
                format!("[core-tx_valid-129] Nonce not increased after validation.")
            }
            Validation::AAPaymasterReturnDataTooShort => {
                format!("[core-tx_valid-130] Return data from paymaster is too short.")
            }
            Validation::AAPaymasterInvalidMagic => {
                format!("[core-tx_valid-131] Invalid magic in paymaster validation.")
            }
            Validation::AAPaymasterContextInvalid => {
                format!("[core-tx_valid-132] Paymaster returned invalid context.")
            }
            Validation::AAPaymasterContextOffsetTooLong => {
                format ! ("[core-tx_valid-133] Paymaster context offset is greater than returndata length.")
            }
            Validation::GasPerPubdataTooHigh => {
                format!("[core-tx_valid-134] The gas-per-pubdata price is unacceptably high.")
            }
            Validation::BlockGasLimitTooHigh => {
                format!("[core-tx_valid-135] The block gas limit is too high.")
            }
            Validation::UpgradeTxNotFirst => {
                format ! ("[core-tx_valid-136] A protocol upgrade transaction must be the first in a block.")
            }
            Validation::UpgradeTxFailed => {
                format ! ("[core-tx_valid-137] A protocol upgrade transaction has failed, which should never happen.")
            }
            Validation::GenericError { message } => {
                format!("[core-tx_valid-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(CommonCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Common {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Common {}
impl NamedError for Common {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for CommonCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Common> for crate::ZksyncError {
    fn from(val: Common) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Common {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Common {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Common {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Common::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Common> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Common) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Common> for crate::serialized::SerializedError {
    fn from(value: Common) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Common {
    fn get_message(&self) -> String {
        match self {
            Common::GenericError { message } => {
                format!("[exec_env-common-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EVM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for EVM {}
impl NamedError for EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<EVM> for crate::ZksyncError {
    fn from(val: EVM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for EVM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EVM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EVM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<EVM> for crate::serialized::SerializedError {
    fn from(value: EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for EVM {
    fn get_message(&self) -> String {
        match self {
            EVM::GenericError { message } => {
                format!("[exec_env-evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(NativeCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Native {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Native {}
impl NamedError for Native {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for NativeCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Native> for crate::ZksyncError {
    fn from(val: Native) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Native {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Native {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Native {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Native::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Native> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Native) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Native> for crate::serialized::SerializedError {
    fn from(value: Native) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Native {
    fn get_message(&self) -> String {
        match self {
            Native::GenericError { message } => {
                format!("[exec_env-native-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(WASMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum WASM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for WASM {}
impl NamedError for WASM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for WASMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<WASM> for crate::ZksyncError {
    fn from(val: WASM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for WASM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for WASM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for WASM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        WASM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<WASM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: WASM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<WASM> for crate::serialized::SerializedError {
    fn from(value: WASM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for WASM {
    fn get_message(&self) -> String {
        match self {
            WASM::GenericError { message } => {
                format!("[exec_env-wasm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Foundry implementation."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for FoundryUpstream {}
impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for FoundryUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryUpstream::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryUpstream {
    fn get_message(&self) -> String {
        match self {
            FoundryUpstream::GenericError { message } => {
                format!("[foundry-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for Foundry."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for FoundryZksync {}
impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for FoundryZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryZksync::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryZksync {
    fn get_message(&self) -> String {
        match self {
            FoundryZksync::GenericError { message } => {
                format!("[foundry-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Hardhat implementation."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for HardhatUpstream {}
impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for HardhatUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatUpstream::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatUpstream {
    fn get_message(&self) -> String {
        match self {
            HardhatUpstream::GenericError { message } => {
                format!("[hardhat-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for HardHat."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for HardhatZksync {}
impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for HardhatZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatZksync::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatZksync {
    fn get_message(&self) -> String {
        match self {
            HardhatZksync::GenericError { message } => {
                format!("[hardhat-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: OS"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(StorageCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Storage {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Storage {}
impl NamedError for Storage {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for StorageCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Storage> for crate::ZksyncError {
    fn from(val: Storage) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Storage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Storage {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Storage {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Storage::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Storage> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Storage) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Storage> for crate::serialized::SerializedError {
    fn from(value: Storage) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Storage {
    fn get_message(&self) -> String {
        match self {
            Storage::GenericError { message } => {
                format!("[os-storage-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: OS"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SystemCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum System {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for System {}
impl NamedError for System {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SystemCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<System> for crate::ZksyncError {
    fn from(val: System) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for System {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for System {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for System {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        System::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<System> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: System) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<System> for crate::serialized::SerializedError {
    fn from(value: System) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for System {
    fn get_message(&self) -> String {
        match self {
            System::GenericError { message } => {
                format!("[os-sys-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: OS"]
#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SystemEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SystemEnvironment {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for SystemEnvironment {}
impl NamedError for SystemEnvironment {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SystemEnvironmentCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<SystemEnvironment> for crate::ZksyncError {
    fn from(val: SystemEnvironment) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for SystemEnvironment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.get_message())
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for SystemEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for SystemEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SystemEnvironment::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<SystemEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SystemEnvironment) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<SystemEnvironment> for crate::serialized::SerializedError {
    fn from(value: SystemEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for SystemEnvironment {
    fn get_message(&self) -> String {
        match self {
            SystemEnvironment::GenericError { message } => {
                format!("[os-env-0] Generic error: {message}")
            }
        }
    }
}
