//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(unused)]
#![allow(clippy::useless_format)]
#![allow(non_camel_case_types)]
#[cfg(feature = "runtime_documentation")]
use crate::documentation::Documented;
use crate::error::domains::*;
#[cfg(feature = "std")]
use crate::error::CustomErrorMessage;
use crate::error::CustomErrorMessageWriter;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use crate::error::NamedError;
use core::fmt;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
use strum_macros::IntoStaticStr;
#[cfg(all(feature = "std", feature = "box_wrapped_errors"))]
pub type Wrapped<E> = Box<E>;
#[cfg(not(feature = "std"))]
pub type Wrapped<E> = E;
#[doc = "Errors originating in the compiler backend for Ethereum VM (EVM)."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for LLVM_EVM {}
impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for LLVM_EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_EVM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for LLVM_EVM {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            LLVM_EVM::GenericError { message } => {
                write!(writer, "[compiler-llvm+evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for LLVM_Era {}
impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for LLVM_Era {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_Era::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for LLVM_Era {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            LLVM_Era::GenericError { message } => {
                write!(writer, "[compiler-llvm+era-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the official Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Solc {}
impl NamedError for Solc {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Solc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Solc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Solc::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Solc {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Solc::GenericError { message } => {
                write!(writer, "[compiler-solc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync fork of Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for SolcFork {}
impl NamedError for SolcFork {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for SolcFork {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for SolcFork {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SolcFork::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for SolcFork {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            SolcFork::GenericError { message } => {
                write!(writer, "[compiler-solc+fork-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Solidity compiler for EraVM and EVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Zksolc {}
impl NamedError for Zksolc {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Zksolc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Zksolc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zksolc::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Zksolc {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Zksolc::GenericError { message } => {
                write!(writer, "[compiler-zksolc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Vyper compiler for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Zkvyper {}
impl NamedError for Zkvyper {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Zkvyper {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zkvyper::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Zkvyper {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Zkvyper::GenericError { message } => {
                write!(writer, "[compiler-zkvyper-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the web3 API."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum API {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for API {}
impl NamedError for API {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for API {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for API {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        API::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for API {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            API::GenericError { message } => {
                write!(writer, "[core-api-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in EraVM virtual machine executing contracts."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for EraVM {}
impl NamedError for EraVM {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for EraVM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for EraVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EraVM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for EraVM {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            EraVM::GenericError { message } => {
                write!(writer, "[core-eravm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the contract execution environment, bootloader, etc."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for ExecutionPlatform {}
impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for ExecutionPlatform {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        ExecutionPlatform::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for ExecutionPlatform {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            ExecutionPlatform::GenericError { message } => {
                write!(writer, "[core-exec-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the sequencer node"]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
    GenericSequencerError { message: String } = 1u32,
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Sequencer {}
impl NamedError for Sequencer {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Sequencer {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Sequencer {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Sequencer::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Sequencer {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Sequencer::GenericSequencerError { message } => {
                write!(writer, "[core-seq-1] Generic error: {message}")
            }
            Sequencer::GenericError { message } => {
                write!(writer, "[core-seq-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(CommonCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Common {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Common {}
impl NamedError for Common {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for CommonCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Common> for crate::ZksyncError {
    fn from(val: Common) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Common {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Common {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Common {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Common::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Common> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Common) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Common> for crate::serialized::SerializedError {
    fn from(value: Common) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Common {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Common::GenericError { message } => {
                write!(writer, "[exec_env-common-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum EVM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for EVM {}
impl NamedError for EVM {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for EVMCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<EVM> for crate::ZksyncError {
    fn from(val: EVM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for EVM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EVM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EVM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<EVM> for crate::serialized::SerializedError {
    fn from(value: EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for EVM {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            EVM::GenericError { message } => {
                write!(writer, "[exec_env-evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(NativeCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Native {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Native {}
impl NamedError for Native {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for NativeCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Native> for crate::ZksyncError {
    fn from(val: Native) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Native {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Native {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Native {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Native::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Native> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Native) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Native> for crate::serialized::SerializedError {
    fn from(value: Native) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Native {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Native::GenericError { message } => {
                write!(writer, "[exec_env-native-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: ExecutionEnvironment"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(WASMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum WASM {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for WASM {}
impl NamedError for WASM {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for WASMCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<WASM> for crate::ZksyncError {
    fn from(val: WASM) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for WASM {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for WASM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for WASM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        WASM::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<WASM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: WASM) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<WASM> for crate::serialized::SerializedError {
    fn from(value: WASM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for WASM {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            WASM::GenericError { message } => {
                write!(writer, "[exec_env-wasm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Foundry implementation."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for FoundryUpstream {}
impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for FoundryUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryUpstream::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for FoundryUpstream {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            FoundryUpstream::GenericError { message } => {
                write!(writer, "[foundry-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for Foundry."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for FoundryZksync {}
impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for FoundryZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryZksync::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for FoundryZksync {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            FoundryZksync::GenericError { message } => {
                write!(writer, "[foundry-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Hardhat implementation."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for HardhatUpstream {}
impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for HardhatUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatUpstream::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for HardhatUpstream {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            HardhatUpstream::GenericError { message } => {
                write!(writer, "[hardhat-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for HardHat."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for HardhatZksync {}
impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for HardhatZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatZksync::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for HardhatZksync {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            HardhatZksync::GenericError { message } => {
                write!(writer, "[hardhat-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: OS"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(StorageCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum Storage {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for Storage {}
impl NamedError for Storage {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for StorageCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<Storage> for crate::ZksyncError {
    fn from(val: Storage) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for Storage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for Storage {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for Storage {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Storage::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<Storage> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Storage) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<Storage> for crate::serialized::SerializedError {
    fn from(value: Storage) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for Storage {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            Storage::GenericError { message } => {
                write!(writer, "[os-storage-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: OS"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SystemCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum System {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for System {}
impl NamedError for System {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for SystemCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<System> for crate::ZksyncError {
    fn from(val: System) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for System {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for System {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for System {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        System::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<System> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: System) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<System> for crate::serialized::SerializedError {
    fn from(value: System) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for System {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            System::GenericError { message } => {
                write!(writer, "[os-sys-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: OS"]
#[repr(u32)]
#[derive(IntoStaticStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq)]
#[cfg_attr(feature = "use_serde", derive(serde::Serialize))]
#[cfg_attr(feature = "use_serde", derive(serde::Deserialize))]
#[strum_discriminants(name(SystemEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(IntoStaticStr, FromRepr))]
#[non_exhaustive]
pub enum SystemEnvironment {
    GenericError { message: String } = 0u32,
}
impl core::error::Error for SystemEnvironment {}
impl NamedError for SystemEnvironment {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl NamedError for SystemEnvironmentCode {
    fn get_error_name(&self) -> &'static str {
        self.into()
    }
}
impl From<SystemEnvironment> for crate::ZksyncError {
    fn from(val: SystemEnvironment) -> Self {
        val.to_unified()
    }
}
impl fmt::Display for SystemEnvironment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.write_message(f)
    }
}
#[cfg(feature = "runtime_documentation")]
impl Documented for SystemEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
#[cfg(feature = "use_anyhow")]
impl From<anyhow::Error> for SystemEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SystemEnvironment::GenericError { message }
    }
}
#[cfg(feature = "packed_errors")]
impl From<SystemEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SystemEnvironment) -> Self {
        crate::packed::pack(value)
    }
}
#[cfg(feature = "serialized_errors")]
impl From<SystemEnvironment> for crate::serialized::SerializedError {
    fn from(value: SystemEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessageWriter for SystemEnvironment {
    fn write_message<W: core::fmt::Write>(&self, writer: &mut W) -> core::fmt::Result {
        match self {
            SystemEnvironment::GenericError { message } => {
                write!(writer, "[os-env-0] Generic error: {message}")
            }
        }
    }
}
