//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(non_camel_case_types)]
#![allow(unused)]
#![cfg_attr(not(feature = "std"), no_std)]
#[cfg(not(feature = "std"))]
extern crate alloc;
#[cfg(not(feature = "std"))]
use alloc::format;
#[cfg(feature = "runtime_documentation")]
pub mod documentation;
pub(crate) mod error;
pub use error::CustomErrorMessage;
pub use error::ICustomError;
pub use error::IError;
pub use error::IUnifiedError;
pub use error::NamedError;
pub(crate) mod identifier;
pub use identifier::Identifier;
pub use identifier::Identifying;
pub use identifier::StructuredErrorCode;
pub(crate) mod kind;
pub use kind::Kind;
#[cfg(feature = "packed_errors")]
pub mod packed;
#[cfg(feature = "serialized_errors")]
pub mod serialized;
#[cfg(feature = "serialized_errors")]
pub mod untyped;
pub use crate::error::domains::ZksyncError;
pub mod anvil_zksync {
    pub use crate::error::domains::AnvilZksync as AnvilZksyncError;
    pub use crate::error::domains::AnvilZksyncCode;
    pub mod env {
        pub use crate::error::definitions::AnvilEnvironment as AnvilEnvironmentError;
        pub type AnvilEnvironmentResult<T> = core::result::Result<T, AnvilEnvironmentError>;
        pub use crate::error::definitions::AnvilEnvironment::GenericError;
        pub use crate::error::definitions::AnvilEnvironment::InvalidArguments;
        pub use crate::error::definitions::AnvilEnvironment::LogFileAccessFailed;
        pub use crate::error::definitions::AnvilEnvironment::LogFileWriteFailed;
        pub use crate::error::definitions::AnvilEnvironment::ServerStartupFailed;
        pub use crate::error::definitions::AnvilEnvironmentCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_env_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: env :: AnvilEnvironmentError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_env_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> AnvilEnvironmentError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::AnvilEnvironment(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod gen {
        pub use crate::error::definitions::AnvilGeneric as AnvilGenericError;
        pub type AnvilGenericResult<T> = core::result::Result<T, AnvilGenericError>;
        pub use crate::error::definitions::AnvilGeneric::GenericError;
        pub use crate::error::definitions::AnvilGenericCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_gen_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: gen :: AnvilGenericError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_gen_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> AnvilGenericError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::AnvilGeneric(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod node {
        pub use crate::error::definitions::AnvilNode as AnvilNodeError;
        pub type AnvilNodeResult<T> = core::result::Result<T, AnvilNodeError>;
        pub use crate::error::definitions::AnvilNode::GenericError;
        pub use crate::error::definitions::AnvilNode::SerializationError;
        pub use crate::error::definitions::AnvilNode::TimestampBackwardsError;
        pub use crate::error::definitions::AnvilNode::TransactionGasEstimationFailed;
        pub use crate::error::definitions::AnvilNode::TransactionHalt;
        pub use crate::error::definitions::AnvilNode::TransactionValidationFailed;
        pub use crate::error::definitions::AnvilNodeCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_node_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: node :: AnvilNodeError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_node_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> AnvilNodeError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::AnvilNode(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod gas_estim {
        pub use crate::error::definitions::GasEstimation as GasEstimationError;
        pub type GasEstimationResult<T> = core::result::Result<T, GasEstimationError>;
        pub use crate::error::definitions::GasEstimation::ExceedsBlockGasLimit;
        pub use crate::error::definitions::GasEstimation::ExceedsLimitForPublishedPubdata;
        pub use crate::error::definitions::GasEstimation::GenericError;
        pub use crate::error::definitions::GasEstimation::TransactionAlwaysHalts;
        pub use crate::error::definitions::GasEstimation::TransactionAlwaysReverts;
        pub use crate::error::definitions::GasEstimation::TransactionHalt;
        pub use crate::error::definitions::GasEstimation::TransactionRevert;
        pub use crate::error::definitions::GasEstimationCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_gas_estim_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: gas_estim :: GasEstimationError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_gas_estim_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> GasEstimationError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::GasEstimation(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod halt {
        pub use crate::error::definitions::Halt as HaltError;
        pub type HaltResult<T> = core::result::Result<T, HaltError>;
        pub use crate::error::definitions::Halt::BootloaderOutOfGas;
        pub use crate::error::definitions::Halt::FailedBlockTimestampAssertion;
        pub use crate::error::definitions::Halt::FailedToAppendTransactionToL2Block;
        pub use crate::error::definitions::Halt::FailedToChargeFee;
        pub use crate::error::definitions::Halt::FailedToMarkFactoryDependencies;
        pub use crate::error::definitions::Halt::FailedToPublishCompressedBytecodes;
        pub use crate::error::definitions::Halt::FailedToSetL2Block;
        pub use crate::error::definitions::Halt::FromIsNotAnAccount;
        pub use crate::error::definitions::Halt::GenericError;
        pub use crate::error::definitions::Halt::InnerTxError;
        pub use crate::error::definitions::Halt::MissingInvocationLimitReached;
        pub use crate::error::definitions::Halt::NotEnoughGasProvided;
        pub use crate::error::definitions::Halt::PayForTxFailed;
        pub use crate::error::definitions::Halt::PaymasterValidationFailed;
        pub use crate::error::definitions::Halt::PrePaymasterPreparationFailed;
        pub use crate::error::definitions::Halt::TooBigGasLimit;
        pub use crate::error::definitions::Halt::TracerCustom;
        pub use crate::error::definitions::Halt::UnexpectedVMBehavior;
        pub use crate::error::definitions::Halt::Unknown;
        pub use crate::error::definitions::Halt::VMPanic;
        pub use crate::error::definitions::Halt::ValidationFailed;
        pub use crate::error::definitions::Halt::ValidationOutOfGas;
        pub use crate::error::definitions::HaltCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_halt_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: halt :: HaltError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_halt_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> HaltError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::Halt(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod revert {
        pub use crate::error::definitions::Revert as RevertError;
        pub type RevertResult<T> = core::result::Result<T, RevertError>;
        pub use crate::error::definitions::Revert::General;
        pub use crate::error::definitions::Revert::GenericError;
        pub use crate::error::definitions::Revert::InnerTxError;
        pub use crate::error::definitions::Revert::Unknown;
        pub use crate::error::definitions::Revert::VmError;
        pub use crate::error::definitions::RevertCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_revert_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: revert :: RevertError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_revert_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> RevertError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::Revert(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod state {
        pub use crate::error::definitions::StateLoader as StateLoaderError;
        pub type StateLoaderResult<T> = core::result::Result<T, StateLoaderError>;
        pub use crate::error::definitions::StateLoader::GenericError;
        pub use crate::error::definitions::StateLoader::LoadEmptyState;
        pub use crate::error::definitions::StateLoader::LoadingStateOverExistingState;
        pub use crate::error::definitions::StateLoader::StateDecompression;
        pub use crate::error::definitions::StateLoader::StateDeserialization;
        pub use crate::error::definitions::StateLoader::StateFileAccess;
        pub use crate::error::definitions::StateLoader::UnknownStateVersion;
        pub use crate::error::definitions::StateLoaderCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_state_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: state :: StateLoaderError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_state_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> StateLoaderError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::StateLoader(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod tx_invalid {
        pub use crate::error::definitions::TransactionValidation as TransactionValidationError;
        pub type TransactionValidationResult<T> =
            core::result::Result<T, TransactionValidationError>;
        pub use crate::error::definitions::TransactionValidation::GasPerPubdataLimit;
        pub use crate::error::definitions::TransactionValidation::GenericError;
        pub use crate::error::definitions::TransactionValidation::InvalidGasLimit;
        pub use crate::error::definitions::TransactionValidation::MaxFeePerGasTooLow;
        pub use crate::error::definitions::TransactionValidation::MaxPriorityFeeGreaterThanMaxFee;
        pub use crate::error::definitions::TransactionValidationCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! anvil_zksync_tx_invalid_generic_error { ($ ($ arg : tt) *) => { zksync_error :: anvil_zksync :: tx_invalid :: TransactionValidationError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_zksync_tx_invalid_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> TransactionValidationError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::AnvilZksyncError {
            super::AnvilZksyncError::TransactionValidation(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
pub mod compiler {
    pub use crate::error::domains::Compiler as CompilerError;
    pub use crate::error::domains::CompilerCode;
    pub mod llvm_evm {
        pub use crate::error::definitions::LLVM_EVM as LLVM_EVMError;
        pub type LLVM_EVMResult<T> = core::result::Result<T, LLVM_EVMError>;
        pub use crate::error::definitions::LLVM_EVMCode as ErrorCode;
        pub use crate::error::definitions::LLVM_EVM::GenericError;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! compiler_llvm_evm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: llvm_evm :: LLVM_EVMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_llvm_evm_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> LLVM_EVMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::LLVM_EVM(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod llvm_era {
        pub use crate::error::definitions::LLVM_Era as LLVM_EraError;
        pub type LLVM_EraResult<T> = core::result::Result<T, LLVM_EraError>;
        pub use crate::error::definitions::LLVM_Era::GenericError;
        pub use crate::error::definitions::LLVM_EraCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! compiler_llvm_era_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: llvm_era :: LLVM_EraError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_llvm_era_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> LLVM_EraError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::LLVM_Era(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod solc {
        pub use crate::error::definitions::Solc as SolcError;
        pub type SolcResult<T> = core::result::Result<T, SolcError>;
        pub use crate::error::definitions::Solc::GenericError;
        pub use crate::error::definitions::SolcCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! compiler_solc_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: solc :: SolcError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_solc_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SolcError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Solc(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod solc_fork {
        pub use crate::error::definitions::SolcFork as SolcForkError;
        pub type SolcForkResult<T> = core::result::Result<T, SolcForkError>;
        pub use crate::error::definitions::SolcFork::GenericError;
        pub use crate::error::definitions::SolcForkCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! compiler_solc_fork_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: solc_fork :: SolcForkError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_solc_fork_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SolcForkError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::SolcFork(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod zksolc {
        pub use crate::error::definitions::Zksolc as ZksolcError;
        pub type ZksolcResult<T> = core::result::Result<T, ZksolcError>;
        pub use crate::error::definitions::Zksolc::GenericError;
        pub use crate::error::definitions::ZksolcCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! compiler_zksolc_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: zksolc :: ZksolcError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_zksolc_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ZksolcError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Zksolc(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod zkvyper {
        pub use crate::error::definitions::Zkvyper as ZkvyperError;
        pub type ZkvyperResult<T> = core::result::Result<T, ZkvyperError>;
        pub use crate::error::definitions::Zkvyper::GenericError;
        pub use crate::error::definitions::ZkvyperCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! compiler_zkvyper_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: zkvyper :: ZkvyperError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_zkvyper_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ZkvyperError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Zkvyper(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
pub mod core {
    pub use crate::error::domains::Core as CoreError;
    pub use crate::error::domains::CoreCode;
    pub mod api {
        pub use crate::error::definitions::API as APIError;
        pub type APIResult<T> = core::result::Result<T, APIError>;
        pub use crate::error::definitions::APICode as ErrorCode;
        pub use crate::error::definitions::API::GenericError;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! core_api_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: api :: APIError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_api_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> APIError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::API(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod eravm {
        pub use crate::error::definitions::EraVM as EraVMError;
        pub type EraVMResult<T> = core::result::Result<T, EraVMError>;
        pub use crate::error::definitions::EraVM::GenericError;
        pub use crate::error::definitions::EraVMCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! core_eravm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: eravm :: EraVMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_eravm_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> EraVMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::EraVM(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod exec {
        pub use crate::error::definitions::ExecutionPlatform as ExecutionPlatformError;
        pub type ExecutionPlatformResult<T> = core::result::Result<T, ExecutionPlatformError>;
        pub use crate::error::definitions::ExecutionPlatform::GenericError;
        pub use crate::error::definitions::ExecutionPlatformCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! core_exec_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: exec :: ExecutionPlatformError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_exec_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ExecutionPlatformError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::ExecutionPlatform(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod seq {
        pub use crate::error::definitions::Sequencer as SequencerError;
        pub type SequencerResult<T> = core::result::Result<T, SequencerError>;
        pub use crate::error::definitions::Sequencer::GenericError;
        pub use crate::error::definitions::Sequencer::GenericSequencerError;
        pub use crate::error::definitions::SequencerCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! core_seq_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: seq :: SequencerError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_seq_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SequencerError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::Sequencer(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod tx_valid {
        pub use crate::error::definitions::Validation as ValidationError;
        pub type ValidationResult<T> = core::result::Result<T, ValidationError>;
        pub use crate::error::definitions::Validation::AAPaymasterContextInvalid;
        pub use crate::error::definitions::Validation::AAPaymasterContextOffsetTooLong;
        pub use crate::error::definitions::Validation::AAPaymasterInvalidMagic;
        pub use crate::error::definitions::Validation::AAPaymasterReturnDataTooShort;
        pub use crate::error::definitions::Validation::AAReceivedInsufficientFees;
        pub use crate::error::definitions::Validation::AARevertAccountPayForTransaction;
        pub use crate::error::definitions::Validation::AARevertAccountPrePaymaster;
        pub use crate::error::definitions::Validation::AARevertAccountValidate;
        pub use crate::error::definitions::Validation::AARevertPaymasterValidateAndPay;
        pub use crate::error::definitions::Validation::AccessListNotSupported;
        pub use crate::error::definitions::Validation::BaseFeeGreaterThanMaxFee;
        pub use crate::error::definitions::Validation::BlockGasLimitTooHigh;
        pub use crate::error::definitions::Validation::CallGasCostMoreThanGasLimit;
        pub use crate::error::definitions::Validation::CallerGasLimitMoreThanBlock;
        pub use crate::error::definitions::Validation::CreateInitCodeSizeLimit;
        pub use crate::error::definitions::Validation::GasPerPubdataTooHigh;
        pub use crate::error::definitions::Validation::GasPriceLessThanBasefee;
        pub use crate::error::definitions::Validation::GenericError;
        pub use crate::error::definitions::Validation::IncorrectFrom;
        pub use crate::error::definitions::Validation::InvalidChainId;
        pub use crate::error::definitions::Validation::InvalidEncoding;
        pub use crate::error::definitions::Validation::InvalidMagic;
        pub use crate::error::definitions::Validation::InvalidReturndataLength;
        pub use crate::error::definitions::Validation::InvalidStructure;
        pub use crate::error::definitions::Validation::LackOfFundForMaxFee;
        pub use crate::error::definitions::Validation::MalleableSignature;
        pub use crate::error::definitions::Validation::NonceNotIncreased;
        pub use crate::error::definitions::Validation::NonceOverflowInTransaction;
        pub use crate::error::definitions::Validation::NonceTooHigh;
        pub use crate::error::definitions::Validation::NonceTooLow;
        pub use crate::error::definitions::Validation::NonceUsedAlready;
        pub use crate::error::definitions::Validation::OutOfGasDuringValidation;
        pub use crate::error::definitions::Validation::OutOfNativeResourcesDuringValidation;
        pub use crate::error::definitions::Validation::OverflowPaymentInTransaction;
        pub use crate::error::definitions::Validation::PriorityFeeGreaterThanMaxFee;
        pub use crate::error::definitions::Validation::RejectCallerWithCode;
        pub use crate::error::definitions::Validation::UpgradeTxFailed;
        pub use crate::error::definitions::Validation::UpgradeTxNotFirst;
        pub use crate::error::definitions::ValidationCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! core_tx_valid_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: tx_valid :: ValidationError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_tx_valid_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ValidationError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::Validation(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
pub mod exec_env {
    pub use crate::error::domains::ExecutionEnvironment as ExecutionEnvironmentError;
    pub use crate::error::domains::ExecutionEnvironmentCode;
    pub mod common {
        pub use crate::error::definitions::Common as CommonError;
        pub type CommonResult<T> = core::result::Result<T, CommonError>;
        pub use crate::error::definitions::Common::GenericError;
        pub use crate::error::definitions::CommonCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! exec_env_common_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: common :: CommonError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::exec_env_common_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> CommonError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::Common(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod evm {
        pub use crate::error::definitions::EVM as EVMError;
        pub type EVMResult<T> = core::result::Result<T, EVMError>;
        pub use crate::error::definitions::EVMCode as ErrorCode;
        pub use crate::error::definitions::EVM::GenericError;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! exec_env_evm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: evm :: EVMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::exec_env_evm_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> EVMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::EVM(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod native {
        pub use crate::error::definitions::Native as NativeError;
        pub type NativeResult<T> = core::result::Result<T, NativeError>;
        pub use crate::error::definitions::Native::GenericError;
        pub use crate::error::definitions::NativeCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! exec_env_native_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: native :: NativeError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::exec_env_native_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> NativeError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::Native(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod wasm {
        pub use crate::error::definitions::WASM as WASMError;
        pub type WASMResult<T> = core::result::Result<T, WASMError>;
        pub use crate::error::definitions::WASMCode as ErrorCode;
        pub use crate::error::definitions::WASM::GenericError;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! exec_env_wasm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: wasm :: WASMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::exec_env_wasm_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> WASMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::WASM(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
pub mod foundry {
    pub use crate::error::domains::Foundry as FoundryError;
    pub use crate::error::domains::FoundryCode;
    pub mod upstream {
        pub use crate::error::definitions::FoundryUpstream as FoundryUpstreamError;
        pub type FoundryUpstreamResult<T> = core::result::Result<T, FoundryUpstreamError>;
        pub use crate::error::definitions::FoundryUpstream::GenericError;
        pub use crate::error::definitions::FoundryUpstreamCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! foundry_upstream_generic_error { ($ ($ arg : tt) *) => { zksync_error :: foundry :: upstream :: FoundryUpstreamError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::foundry_upstream_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> FoundryUpstreamError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::FoundryError {
            super::FoundryError::FoundryUpstream(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod zksync {
        pub use crate::error::definitions::FoundryZksync as FoundryZksyncError;
        pub type FoundryZksyncResult<T> = core::result::Result<T, FoundryZksyncError>;
        pub use crate::error::definitions::FoundryZksync::GenericError;
        pub use crate::error::definitions::FoundryZksyncCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! foundry_zksync_generic_error { ($ ($ arg : tt) *) => { zksync_error :: foundry :: zksync :: FoundryZksyncError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::foundry_zksync_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> FoundryZksyncError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::FoundryError {
            super::FoundryError::FoundryZksync(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
pub mod hardhat {
    pub use crate::error::domains::Hardhat as HardhatError;
    pub use crate::error::domains::HardhatCode;
    pub mod upstream {
        pub use crate::error::definitions::HardhatUpstream as HardhatUpstreamError;
        pub type HardhatUpstreamResult<T> = core::result::Result<T, HardhatUpstreamError>;
        pub use crate::error::definitions::HardhatUpstream::GenericError;
        pub use crate::error::definitions::HardhatUpstreamCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! hardhat_upstream_generic_error { ($ ($ arg : tt) *) => { zksync_error :: hardhat :: upstream :: HardhatUpstreamError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::hardhat_upstream_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> HardhatUpstreamError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::HardhatError {
            super::HardhatError::HardhatUpstream(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod zksync {
        pub use crate::error::definitions::HardhatZksync as HardhatZksyncError;
        pub type HardhatZksyncResult<T> = core::result::Result<T, HardhatZksyncError>;
        pub use crate::error::definitions::HardhatZksync::GenericError;
        pub use crate::error::definitions::HardhatZksyncCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! hardhat_zksync_generic_error { ($ ($ arg : tt) *) => { zksync_error :: hardhat :: zksync :: HardhatZksyncError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::hardhat_zksync_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> HardhatZksyncError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::HardhatError {
            super::HardhatError::HardhatZksync(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
pub mod os {
    pub use crate::error::domains::Os as OsError;
    pub use crate::error::domains::OsCode;
    pub mod storage {
        pub use crate::error::definitions::Storage as StorageError;
        pub type StorageResult<T> = core::result::Result<T, StorageError>;
        pub use crate::error::definitions::Storage::GenericError;
        pub use crate::error::definitions::StorageCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! os_storage_generic_error { ($ ($ arg : tt) *) => { zksync_error :: os :: storage :: StorageError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::os_storage_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> StorageError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::OsError {
            super::OsError::Storage(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod sys {
        pub use crate::error::definitions::System as SystemError;
        pub type SystemResult<T> = core::result::Result<T, SystemError>;
        pub use crate::error::definitions::System::GenericError;
        pub use crate::error::definitions::SystemCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! os_sys_generic_error { ($ ($ arg : tt) *) => { zksync_error :: os :: sys :: SystemError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::os_sys_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SystemError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::OsError {
            super::OsError::System(GenericError {
                message: format!("{}", err),
            })
        }
    }
    pub mod env {
        pub use crate::error::definitions::SystemEnvironment as SystemEnvironmentError;
        pub type SystemEnvironmentResult<T> = core::result::Result<T, SystemEnvironmentError>;
        pub use crate::error::definitions::SystemEnvironment::GenericError;
        pub use crate::error::definitions::SystemEnvironmentCode as ErrorCode;
        #[cfg(not(feature = "std"))]
        use alloc::format;
        #[macro_export]
        macro_rules ! os_env_generic_error { ($ ($ arg : tt) *) => { zksync_error :: os :: env :: SystemEnvironmentError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::os_env_generic_error as generic_error;
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SystemEnvironmentError {
            GenericError {
                message: format!("{}", err),
            }
        }
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::OsError {
            super::OsError::SystemEnvironment(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
