//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(non_camel_case_types)]
#![allow(unused)]
#![allow(clippy::uninlined_format_args)]
#![doc = r"# Domains"]
#![doc = "- compiler"]
#![doc = "   - llvm_evm"]
#![doc = "   - llvm_era"]
#![doc = "   - solc"]
#![doc = "   - solc_fork"]
#![doc = "   - zksolc"]
#![doc = "   - zkvyper"]
#![doc = "- core"]
#![doc = "   - api"]
#![doc = "   - eravm"]
#![doc = "   - exec"]
#![doc = "   - seq"]
#![doc = "- exec_env"]
#![doc = "   - common"]
#![doc = "   - evm"]
#![doc = "   - native"]
#![doc = "   - wasm"]
#![doc = "- foundry"]
#![doc = "   - upstream"]
#![doc = "   - zksync"]
#![doc = "- hardhat"]
#![doc = "   - upstream"]
#![doc = "   - zksync"]
#![doc = "- os"]
#![doc = "   - storage"]
#![doc = "   - sys"]
#![doc = "   - env"]
#![cfg_attr(not(feature = "std"), no_std)]
#[cfg(feature = "runtime_documentation")]
pub mod documentation;
pub(crate) mod error;
pub use error::CustomErrorMessage;
pub use error::ICustomError;
pub use error::IError;
pub use error::IUnifiedError;
pub use error::NamedError;
pub(crate) mod identifier;
pub use identifier::Identifier;
pub use identifier::Identifying;
pub use identifier::StructuredErrorCode;
pub(crate) mod kind;
pub use kind::Kind;
#[cfg(feature = "packed_errors")]
pub mod packed;
#[cfg(feature = "serialized_errors")]
pub mod serialized;
#[cfg(feature = "serialized_errors")]
pub mod untyped;
pub use crate::error::domains::ZksyncError;
#[doc = "CompilerError"]
#[doc = "   - llvm_evm"]
#[doc = "   - llvm_era"]
#[doc = "   - solc"]
#[doc = "   - solc_fork"]
#[doc = "   - zksolc"]
#[doc = "   - zkvyper"]
pub mod compiler {
    pub use crate::error::domains::Compiler as CompilerError;
    pub use crate::error::domains::CompilerCode;
    #[doc = "# LLVM_EVM"]
    #[doc = "   - GenericError"]
    pub mod llvm_evm {
        pub use crate::error::definitions::LLVM_EVM as LLVM_EVMError;
        pub type LLVM_EVMResult<T> = core::result::Result<T, LLVM_EVMError>;
        pub use crate::error::definitions::LLVM_EVMCode as ErrorCode;
        pub use crate::error::definitions::LLVM_EVM::GenericError;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! compiler_llvm_evm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: llvm_evm :: LLVM_EVMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! compiler_llvm_evm_generic_error {
            ($ arg : expr) => {
                zksync_error::compiler::llvm_evm::LLVM_EVMError::GenericError { message: $arg }
            };
        }
        pub use crate::compiler_llvm_evm_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> LLVM_EVMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::LLVM_EVM(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# LLVM_Era"]
    #[doc = "   - GenericError"]
    pub mod llvm_era {
        pub use crate::error::definitions::LLVM_Era as LLVM_EraError;
        pub type LLVM_EraResult<T> = core::result::Result<T, LLVM_EraError>;
        pub use crate::error::definitions::LLVM_Era::GenericError;
        pub use crate::error::definitions::LLVM_EraCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! compiler_llvm_era_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: llvm_era :: LLVM_EraError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! compiler_llvm_era_generic_error {
            ($ arg : expr) => {
                zksync_error::compiler::llvm_era::LLVM_EraError::GenericError { message: $arg }
            };
        }
        pub use crate::compiler_llvm_era_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> LLVM_EraError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::LLVM_Era(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# Solc"]
    #[doc = "   - GenericError"]
    pub mod solc {
        pub use crate::error::definitions::Solc as SolcError;
        pub type SolcResult<T> = core::result::Result<T, SolcError>;
        pub use crate::error::definitions::Solc::GenericError;
        pub use crate::error::definitions::SolcCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! compiler_solc_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: solc :: SolcError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! compiler_solc_generic_error {
            ($ arg : expr) => {
                zksync_error::compiler::solc::SolcError::GenericError { message: $arg }
            };
        }
        pub use crate::compiler_solc_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SolcError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Solc(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# SolcFork"]
    #[doc = "   - GenericError"]
    pub mod solc_fork {
        pub use crate::error::definitions::SolcFork as SolcForkError;
        pub type SolcForkResult<T> = core::result::Result<T, SolcForkError>;
        pub use crate::error::definitions::SolcFork::GenericError;
        pub use crate::error::definitions::SolcForkCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! compiler_solc_fork_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: solc_fork :: SolcForkError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! compiler_solc_fork_generic_error {
            ($ arg : expr) => {
                zksync_error::compiler::solc_fork::SolcForkError::GenericError { message: $arg }
            };
        }
        pub use crate::compiler_solc_fork_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SolcForkError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::SolcFork(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# Zksolc"]
    #[doc = "   - GenericError"]
    pub mod zksolc {
        pub use crate::error::definitions::Zksolc as ZksolcError;
        pub type ZksolcResult<T> = core::result::Result<T, ZksolcError>;
        pub use crate::error::definitions::Zksolc::GenericError;
        pub use crate::error::definitions::ZksolcCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! compiler_zksolc_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: zksolc :: ZksolcError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! compiler_zksolc_generic_error {
            ($ arg : expr) => {
                zksync_error::compiler::zksolc::ZksolcError::GenericError { message: $arg }
            };
        }
        pub use crate::compiler_zksolc_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ZksolcError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Zksolc(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# Zkvyper"]
    #[doc = "   - GenericError"]
    pub mod zkvyper {
        pub use crate::error::definitions::Zkvyper as ZkvyperError;
        pub type ZkvyperResult<T> = core::result::Result<T, ZkvyperError>;
        pub use crate::error::definitions::Zkvyper::GenericError;
        pub use crate::error::definitions::ZkvyperCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! compiler_zkvyper_generic_error { ($ ($ arg : tt) *) => { zksync_error :: compiler :: zkvyper :: ZkvyperError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! compiler_zkvyper_generic_error {
            ($ arg : expr) => {
                zksync_error::compiler::zkvyper::ZkvyperError::GenericError { message: $arg }
            };
        }
        pub use crate::compiler_zkvyper_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ZkvyperError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Zkvyper(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
#[doc = "CoreError"]
#[doc = "   - api"]
#[doc = "   - eravm"]
#[doc = "   - exec"]
#[doc = "   - seq"]
pub mod core {
    pub use crate::error::domains::Core as CoreError;
    pub use crate::error::domains::CoreCode;
    #[doc = "# API"]
    #[doc = "   - GenericError"]
    pub mod api {
        pub use crate::error::definitions::API as APIError;
        pub type APIResult<T> = core::result::Result<T, APIError>;
        pub use crate::error::definitions::APICode as ErrorCode;
        pub use crate::error::definitions::API::GenericError;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! core_api_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: api :: APIError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! core_api_generic_error {
            ($ arg : expr) => {
                zksync_error::core::api::APIError::GenericError { message: $arg }
            };
        }
        pub use crate::core_api_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> APIError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::API(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# EraVM"]
    #[doc = "   - GenericError"]
    pub mod eravm {
        pub use crate::error::definitions::EraVM as EraVMError;
        pub type EraVMResult<T> = core::result::Result<T, EraVMError>;
        pub use crate::error::definitions::EraVM::GenericError;
        pub use crate::error::definitions::EraVMCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! core_eravm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: eravm :: EraVMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! core_eravm_generic_error {
            ($ arg : expr) => {
                zksync_error::core::eravm::EraVMError::GenericError { message: $arg }
            };
        }
        pub use crate::core_eravm_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> EraVMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::EraVM(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# ExecutionPlatform"]
    #[doc = "   - GenericError"]
    pub mod exec {
        pub use crate::error::definitions::ExecutionPlatform as ExecutionPlatformError;
        pub type ExecutionPlatformResult<T> = core::result::Result<T, ExecutionPlatformError>;
        pub use crate::error::definitions::ExecutionPlatform::GenericError;
        pub use crate::error::definitions::ExecutionPlatformCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! core_exec_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: exec :: ExecutionPlatformError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! core_exec_generic_error {
            ($ arg : expr) => {
                zksync_error::core::exec::ExecutionPlatformError::GenericError { message: $arg }
            };
        }
        pub use crate::core_exec_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> ExecutionPlatformError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::ExecutionPlatform(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# Sequencer"]
    #[doc = "   - GenericSequencerError"]
    #[doc = "   - GenericError"]
    pub mod seq {
        pub use crate::error::definitions::Sequencer as SequencerError;
        pub type SequencerResult<T> = core::result::Result<T, SequencerError>;
        pub use crate::error::definitions::Sequencer::GenericError;
        pub use crate::error::definitions::Sequencer::GenericSequencerError;
        pub use crate::error::definitions::SequencerCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! core_seq_generic_error { ($ ($ arg : tt) *) => { zksync_error :: core :: seq :: SequencerError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! core_seq_generic_error {
            ($ arg : expr) => {
                zksync_error::core::seq::SequencerError::GenericError { message: $arg }
            };
        }
        pub use crate::core_seq_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SequencerError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::Sequencer(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
#[doc = "ExecutionEnvironmentError"]
#[doc = "   - common"]
#[doc = "   - evm"]
#[doc = "   - native"]
#[doc = "   - wasm"]
pub mod exec_env {
    pub use crate::error::domains::ExecutionEnvironment as ExecutionEnvironmentError;
    pub use crate::error::domains::ExecutionEnvironmentCode;
    #[doc = "# Common"]
    #[doc = "   - GenericError"]
    pub mod common {
        pub use crate::error::definitions::Common as CommonError;
        pub type CommonResult<T> = core::result::Result<T, CommonError>;
        pub use crate::error::definitions::Common::GenericError;
        pub use crate::error::definitions::CommonCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! exec_env_common_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: common :: CommonError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! exec_env_common_generic_error {
            ($ arg : expr) => {
                zksync_error::exec_env::common::CommonError::GenericError { message: $arg }
            };
        }
        pub use crate::exec_env_common_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> CommonError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::Common(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# EVM"]
    #[doc = "   - GenericError"]
    pub mod evm {
        pub use crate::error::definitions::EVM as EVMError;
        pub type EVMResult<T> = core::result::Result<T, EVMError>;
        pub use crate::error::definitions::EVMCode as ErrorCode;
        pub use crate::error::definitions::EVM::GenericError;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! exec_env_evm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: evm :: EVMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! exec_env_evm_generic_error {
            ($ arg : expr) => {
                zksync_error::exec_env::evm::EVMError::GenericError { message: $arg }
            };
        }
        pub use crate::exec_env_evm_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> EVMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::EVM(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# Native"]
    #[doc = "   - GenericError"]
    pub mod native {
        pub use crate::error::definitions::Native as NativeError;
        pub type NativeResult<T> = core::result::Result<T, NativeError>;
        pub use crate::error::definitions::Native::GenericError;
        pub use crate::error::definitions::NativeCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! exec_env_native_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: native :: NativeError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! exec_env_native_generic_error {
            ($ arg : expr) => {
                zksync_error::exec_env::native::NativeError::GenericError { message: $arg }
            };
        }
        pub use crate::exec_env_native_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> NativeError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::Native(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# WASM"]
    #[doc = "   - GenericError"]
    pub mod wasm {
        pub use crate::error::definitions::WASM as WASMError;
        pub type WASMResult<T> = core::result::Result<T, WASMError>;
        pub use crate::error::definitions::WASMCode as ErrorCode;
        pub use crate::error::definitions::WASM::GenericError;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! exec_env_wasm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: exec_env :: wasm :: WASMError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! exec_env_wasm_generic_error {
            ($ arg : expr) => {
                zksync_error::exec_env::wasm::WASMError::GenericError { message: $arg }
            };
        }
        pub use crate::exec_env_wasm_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> WASMError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::ExecutionEnvironmentError {
            super::ExecutionEnvironmentError::WASM(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
#[doc = "FoundryError"]
#[doc = "   - upstream"]
#[doc = "   - zksync"]
pub mod foundry {
    pub use crate::error::domains::Foundry as FoundryError;
    pub use crate::error::domains::FoundryCode;
    #[doc = "# FoundryUpstream"]
    #[doc = "   - GenericError"]
    pub mod upstream {
        pub use crate::error::definitions::FoundryUpstream as FoundryUpstreamError;
        pub type FoundryUpstreamResult<T> = core::result::Result<T, FoundryUpstreamError>;
        pub use crate::error::definitions::FoundryUpstream::GenericError;
        pub use crate::error::definitions::FoundryUpstreamCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! foundry_upstream_generic_error { ($ ($ arg : tt) *) => { zksync_error :: foundry :: upstream :: FoundryUpstreamError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! foundry_upstream_generic_error {
            ($ arg : expr) => {
                zksync_error::foundry::upstream::FoundryUpstreamError::GenericError {
                    message: $arg,
                }
            };
        }
        pub use crate::foundry_upstream_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> FoundryUpstreamError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::FoundryError {
            super::FoundryError::FoundryUpstream(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# FoundryZksync"]
    #[doc = "   - GenericError"]
    pub mod zksync {
        pub use crate::error::definitions::FoundryZksync as FoundryZksyncError;
        pub type FoundryZksyncResult<T> = core::result::Result<T, FoundryZksyncError>;
        pub use crate::error::definitions::FoundryZksync::GenericError;
        pub use crate::error::definitions::FoundryZksyncCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! foundry_zksync_generic_error { ($ ($ arg : tt) *) => { zksync_error :: foundry :: zksync :: FoundryZksyncError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! foundry_zksync_generic_error {
            ($ arg : expr) => {
                zksync_error::foundry::zksync::FoundryZksyncError::GenericError { message: $arg }
            };
        }
        pub use crate::foundry_zksync_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> FoundryZksyncError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::FoundryError {
            super::FoundryError::FoundryZksync(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
#[doc = "HardhatError"]
#[doc = "   - upstream"]
#[doc = "   - zksync"]
pub mod hardhat {
    pub use crate::error::domains::Hardhat as HardhatError;
    pub use crate::error::domains::HardhatCode;
    #[doc = "# HardhatUpstream"]
    #[doc = "   - GenericError"]
    pub mod upstream {
        pub use crate::error::definitions::HardhatUpstream as HardhatUpstreamError;
        pub type HardhatUpstreamResult<T> = core::result::Result<T, HardhatUpstreamError>;
        pub use crate::error::definitions::HardhatUpstream::GenericError;
        pub use crate::error::definitions::HardhatUpstreamCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! hardhat_upstream_generic_error { ($ ($ arg : tt) *) => { zksync_error :: hardhat :: upstream :: HardhatUpstreamError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! hardhat_upstream_generic_error {
            ($ arg : expr) => {
                zksync_error::hardhat::upstream::HardhatUpstreamError::GenericError {
                    message: $arg,
                }
            };
        }
        pub use crate::hardhat_upstream_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> HardhatUpstreamError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::HardhatError {
            super::HardhatError::HardhatUpstream(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# HardhatZksync"]
    #[doc = "   - GenericError"]
    pub mod zksync {
        pub use crate::error::definitions::HardhatZksync as HardhatZksyncError;
        pub type HardhatZksyncResult<T> = core::result::Result<T, HardhatZksyncError>;
        pub use crate::error::definitions::HardhatZksync::GenericError;
        pub use crate::error::definitions::HardhatZksyncCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! hardhat_zksync_generic_error { ($ ($ arg : tt) *) => { zksync_error :: hardhat :: zksync :: HardhatZksyncError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! hardhat_zksync_generic_error {
            ($ arg : expr) => {
                zksync_error::hardhat::zksync::HardhatZksyncError::GenericError { message: $arg }
            };
        }
        pub use crate::hardhat_zksync_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> HardhatZksyncError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::HardhatError {
            super::HardhatError::HardhatZksync(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
#[doc = "OsError"]
#[doc = "   - storage"]
#[doc = "   - sys"]
#[doc = "   - env"]
pub mod os {
    pub use crate::error::domains::Os as OsError;
    pub use crate::error::domains::OsCode;
    #[doc = "# Storage"]
    #[doc = "   - GenericError"]
    pub mod storage {
        pub use crate::error::definitions::Storage as StorageError;
        pub type StorageResult<T> = core::result::Result<T, StorageError>;
        pub use crate::error::definitions::Storage::GenericError;
        pub use crate::error::definitions::StorageCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! os_storage_generic_error { ($ ($ arg : tt) *) => { zksync_error :: os :: storage :: StorageError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! os_storage_generic_error {
            ($ arg : expr) => {
                zksync_error::os::storage::StorageError::GenericError { message: $arg }
            };
        }
        pub use crate::os_storage_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> StorageError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::OsError {
            super::OsError::Storage(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# System"]
    #[doc = "   - GenericError"]
    pub mod sys {
        pub use crate::error::definitions::System as SystemError;
        pub type SystemResult<T> = core::result::Result<T, SystemError>;
        pub use crate::error::definitions::System::GenericError;
        pub use crate::error::definitions::SystemCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! os_sys_generic_error { ($ ($ arg : tt) *) => { zksync_error :: os :: sys :: SystemError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! os_sys_generic_error {
            ($ arg : expr) => {
                zksync_error::os::sys::SystemError::GenericError { message: $arg }
            };
        }
        pub use crate::os_sys_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SystemError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::OsError {
            super::OsError::System(GenericError {
                message: format!("{}", err),
            })
        }
    }
    #[doc = "# SystemEnvironment"]
    #[doc = "   - GenericError"]
    pub mod env {
        pub use crate::error::definitions::SystemEnvironment as SystemEnvironmentError;
        pub type SystemEnvironmentResult<T> = core::result::Result<T, SystemEnvironmentError>;
        pub use crate::error::definitions::SystemEnvironment::GenericError;
        pub use crate::error::definitions::SystemEnvironmentCode as ErrorCode;
        #[cfg(feature = "std")]
        #[macro_export]
        macro_rules ! os_env_generic_error { ($ ($ arg : tt) *) => { zksync_error :: os :: env :: SystemEnvironmentError :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        #[cfg(not(feature = "std"))]
        #[macro_export]
        macro_rules! os_env_generic_error {
            ($ arg : expr) => {
                zksync_error::os::env::SystemEnvironmentError::GenericError { message: $arg }
            };
        }
        pub use crate::os_env_generic_error as generic_error;
        #[cfg(feature = "std")]
        pub fn to_generic<T: core::fmt::Display>(err: T) -> SystemEnvironmentError {
            GenericError {
                message: format!("{}", err),
            }
        }
        #[cfg(feature = "std")]
        pub fn to_domain<T: core::fmt::Display>(err: T) -> super::OsError {
            super::OsError::SystemEnvironment(GenericError {
                message: format!("{}", err),
            })
        }
    }
}
