//!
//! Parser for access lists.
//! See [ZkSyncTransaction] for more details on encoding format.
//!

use crate::bootloader::Bytes32;
use crate::bootloader::TX_OFFSET;
use ruint::aliases::{B160, U256};

pub struct AccessListParser {
    pub offset: usize,
}

impl AccessListParser {
    pub fn into_iter<'a>(&self, slice: &'a [u8]) -> Result<AccessListIter<'a>, ()> {
        AccessListIter::new(slice, self.offset)
    }
}

pub struct AccessListIter<'a> {
    slice: &'a [u8],
    pub(crate) count: usize,
    head_start: usize,
    index: usize,
}

impl<'a> AccessListIter<'a> {
    fn parse_u256(slice: &'a [u8], offset: usize) -> Result<U256, ()> {
        Ok(U256::from_be_slice(
            slice.get(offset..(offset + 32)).ok_or(())?,
        ))
    }

    fn new(slice: &'a [u8], offset: usize) -> Result<Self, ()> {
        // Ignore pre tx buffer:
        let slice = &slice[TX_OFFSET..];
        // Reserved dynamic is a bytestring of a list,
        // so that we can add fields later on.

        let bytestring_len = Self::parse_u256(slice, offset)?.as_limbs()[0] as usize;
        if bytestring_len == 0 {
            // If empty bytestring, interpret as empty list
            return Ok(AccessListIter {
                slice,
                count: 0,
                head_start: offset + 32,
                index: 0,
            });
        }
        let offset = offset + 32;

        // For now, it only has the access list
        let outer_offset = Self::parse_u256(slice, offset)?.as_limbs()[0] as usize;
        let outer_base = offset + outer_offset;
        let outer_len = Self::parse_u256(slice, outer_base)?.as_limbs()[0] as usize;
        if outer_len != 1 {
            return Err(());
        }

        let access_list_rel_offset =
            Self::parse_u256(slice, outer_base + 32)?.as_limbs()[0] as usize;
        let access_list_base = outer_base + 32 + access_list_rel_offset;
        let count = Self::parse_u256(slice, access_list_base)?.as_limbs()[0] as usize;
        let head_start = access_list_base + 32;

        Ok(AccessListIter {
            slice,
            count,
            head_start,
            index: 0,
        })
    }

    fn parse_current(&mut self) -> Result<(B160, StorageKeysIter<'a>), ()> {
        // Assume index < count, checked by iterator impl
        let offset = self.head_start + self.index.checked_mul(32).ok_or(())?;
        let item_ptr_offset = Self::parse_u256(self.slice, offset)?.as_limbs()[0] as usize;
        let item_offset = self.head_start + item_ptr_offset;
        let address_bytes = &self.slice.get(item_offset..item_offset + 32).ok_or(())?[12..];
        let address = B160::try_from_be_slice(address_bytes).unwrap();
        let keys_ptr_offset =
            Self::parse_u256(self.slice, item_offset + 32)?.as_limbs()[0] as usize;
        let keys_offset = item_offset + keys_ptr_offset;
        let keys_len = Self::parse_u256(self.slice, keys_offset)?.as_limbs()[0] as usize;
        let keys_slice = self.slice.get(keys_offset + 32..).ok_or(())?;

        Ok((
            address,
            StorageKeysIter {
                slice: keys_slice,
                index: 0,
                count: keys_len,
            },
        ))
    }
}

pub struct StorageKeysIter<'a> {
    slice: &'a [u8],
    index: usize,
    pub(crate) count: usize,
}

impl<'a> StorageKeysIter<'a> {
    fn parse_current(&mut self) -> Result<Bytes32, ()> {
        // Assume index < count, checked by iterator impl
        let offset = self.index.checked_mul(32).ok_or(())?;
        let bytes = self.slice.get(offset..offset + 32).ok_or(())?;
        let item = Bytes32::from_array(bytes.try_into().unwrap());
        Ok(item)
    }
}

impl<'a> Iterator for AccessListIter<'a> {
    type Item = Result<(B160, StorageKeysIter<'a>), ()>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index >= self.count {
            return None;
        }
        let current = self.parse_current();
        self.index += 1;
        Some(current)
    }
}

impl<'a> Iterator for StorageKeysIter<'a> {
    type Item = Result<Bytes32, ()>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index >= self.count {
            return None;
        }
        let current = self.parse_current();
        self.index += 1;
        Some(current)
    }
}

// In tests/rig/src/utils.rs we actually check the correctness of fields,
// we just check lengths here.
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_access_list_parser_empty_bytes() {
        // Empty list encoded as empty bytes (backwards compatibility)
        let encoded = hex::decode("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000").unwrap();

        let parser = AccessListParser { offset: 0 };
        let mut iter = parser.into_iter(&encoded).expect("Must parse access list");
        assert!(iter.next().is_none())
    }

    #[test]
    fn test_access_list_parser_empty_list() {
        // Empty access list encoded as bytes of empty list
        let encoded = hex::decode("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000").unwrap();

        let parser = AccessListParser { offset: 0 };
        let mut iter = parser.into_iter(&encoded).expect("Must parse access list");
        assert!(iter.next().is_none())
    }

    #[test]
    fn test_access_list_parser_1_1_0() {
        // Access list with 1 element with 0 storage keys
        let encoded = hex::decode("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000").unwrap();

        let parser = AccessListParser { offset: 0 };
        let mut iter = parser.into_iter(&encoded).expect("Must parse access list");
        // Check list has 1 items:
        assert_eq!(iter.count, 1);
        let (_, keys1) = iter
            .next()
            .expect("Must have first")
            .expect("Must parse first");
        assert_eq!(keys1.count, 0);
        assert!(iter.next().is_none())
    }

    #[test]
    fn test_access_list_parser_1_1_2() {
        // Access list with 1 element with 2 storage keys
        let encoded = hex::decode("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000011111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000222222222222222222222222222222222222222222222222222222222222222223333333333333333333333333333333333333333333333333333333333333333").unwrap();

        let parser = AccessListParser { offset: 0 };
        let mut iter = parser.into_iter(&encoded).expect("Must parse access list");
        // Check list has 1 items:
        assert_eq!(iter.count, 1);
        let (_, keys1) = iter
            .next()
            .expect("Must have first")
            .expect("Must parse first");
        assert_eq!(keys1.count, 2);
        assert!(iter.next().is_none())
    }

    #[test]
    fn test_access_list_parser_2_2_2() {
        // Access list with 2 elements, each with 2 keys
        let encoded = hex::decode("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000001111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000022222222222222222222222222222222222222222222222222222222222222222333333333333333333333333333333333333333333333333333333333333333300000000000000000000000010101010101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000244444444444444444444444444444444444444444444444444444444444444445555555555555555555555555555555555555555555555555555555555555555").unwrap();

        let parser = AccessListParser { offset: 0 };
        let mut iter = parser.into_iter(&encoded).expect("Must parse access list");
        // Check list has 2 items:
        assert_eq!(iter.count, 2);
        let (_, keys1) = iter
            .next()
            .expect("Must have first")
            .expect("Must parse first");
        assert_eq!(keys1.count, 2);
        let (_, keys2) = iter
            .next()
            .expect("Must have second")
            .expect("Must parse second");
        assert_eq!(keys2.count, 2);
        assert!(iter.next().is_none())
    }
}
