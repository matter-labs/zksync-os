# L1 integration

ZKsyncOS will be used for ZK rollups/validiums, which means that state transition correctness should be verified on the settlement layer (we'll call it l1 for simplicity).
More precisely, we will store some state commitment on the settlement layer, and for each block/batch, we are going to generate a proof that will prove that there are inputs to perform valid state transition from the state commitment saved on l1 to some other.
It means that the state before and after transition should be a part of ZK proof public input(or part of preimage). But also public input should include other data for different purposes: messaging, DA validation, and inputs validation.

Apart from that, we are going to implement a messaging mechanism, that allows to send trustless messages from the settlement layer to chain(l2) and back.
This mechanism will be [Era VM compatible](https://docs.zksync.io/zksync-protocol/rollup/l1_l2_communication), it includes l1 -> l2 txs and l2 -> l1 messages.

## Public input structure

By convention, final values from registers x10-x17 will be exposed as proof public input by our RISC-V prover.
As was mentioned we should expose some information about the state transition via public input.

### Simplified example
Let's first describe a simplified example of how it could look to prove state transition on the settlement layer just for understanding:
`public_input = keccak256(state_commitment_before, state_commitment_after, pubdata_keccak256, l1_txs_hash, l2_to_l1_messages_merkle_tree_root)`

Then on the settlement layer in order to make a state transition we should verify the proof, open the preimage to the public input, and:
- check that `state_commitment_before` is the one saved in the chain contract
- update state commitment saved in the contract to `state_commitment_after`
- validate that we passed in calldata preimage to `pubdata_keccak256`. Pubdata - data needed for chain execution, in our case to recover state and l2 to l1 messages.
- open l1_txs_hash, and check that such transactions were indeed requested on the settlement layer. After that mark them as processed somehow.
- publish `l2_to_l1_messages_merkle_tree_root`, so users will be able to prove some message inclusion on the settlement layer

### Aggregation

The current design is not finalized, but most likely we'll implement block aggregation.
It's going to be a separate rust(compiled to risc-v) program that verifies block proofs and combines their inputs/outputs.
And only after such aggregated blocks set will be proven on the settlement layer at once.
It means that block public input should be optimized, and designed for future aggregation.

Please note, that aggregation itself is out of scope.

### Block(pre aggregation) public input

In practice, we may want to have a few levels of aggregation, so this public input was designed to also present a range of blocks.
By range, we mean a sequential set of blocks.

Block(s) public input will be computed as `blake2s` hash of the following values(concatenated):
- `chain_state_commitment_before`
- `chain_state_commitment_after`
- `blocks_output_hash`

Where
- `chain_state_commitment_before` is `blake2s` hash of(concatenation):
  - `state_root`
  - `next_free_slot`
  - `block_number`
  - `last_256_block_hashes_blake`
  - `last_block_timestamp`
    before the block(s).
- `chain_state_commitment_after` same hash, but of values after the block(s).
- `blocks_output_hash` is `blake2s` hash of(concatenation):
  - `used_chain_id`
  - `first_block_timestamp`
  - `last_block_timestamp` (equals to `first_block_timestamp` for a single block)
  - `pubdata_blake2s_hash`
  - `priority_ops_hashes_blakes2s_hash` (l1 txs)
  - `l2_to_l1_logs_hashes_blake2s_hash`
  - `upgrade_tx_hash`

Chain state commitment includes all the state needed for the trustless execution of the next block.
For more details about `state_root` and `next_free_slot` see state tree information.
Although the last 256 block hashes can be derived from the last block(as each block hash contains the previous),
we are saving linear blakes2s hash of 256 blocks separately for optimization purposes.

Block output includes used inputs to validate on the settlement layer(chain id and block timestamp(s)),
Pubdata(data needed to recover state and l2 -> l1 messaging) commitment and fields for messaging.

Please note, that we are using proving `blake2s` hash, as this hashes shouldn't be calculated on the settlement layer.
We need to calculate them only during block proving and in the aggregation program.

### Batch(post aggregation) public input

By batch we'll call the range of blocks that will be sent on l1, and batch public input is the one that will be opened on the settlement layer.
The batch public input is not generated by the ZKsyncOS program but is provided for better understanding.
It equals to `keccak256` hash of(concatenation):
- `chain_state_commitment_before`
- `chain_state_commitment_after`
- `batch_output_hash`

Where chain state commitments are the same `blake2s` hashes of the state before and after as for block(s) PI.
And `batch_output_hash` is `keccak256` of the following fields(concatenated):
- `used_chain_id`
- `first_block_timestamp`
- `last_block_timestamp`
- `pubdata_commitment_scheme`
- `pubdata_commitment`
- `number_of_layer_1_txs`
- `rolling_l1_txs_keccak256`
- `l2_logs_tree_root`
- `upgrade_tx_hash`

This includes almost the same data as block(s) output, with 2 main differences:
- `l2_logs_tree_root` instead `l2_to_l1_logs_hashes_blake2s_hash`, we'll build tree during aggregation.
- `pubdata_commitment_scheme` and `pubdata_commitment` instead of `blake2s`. We can generate different pubdata commitment during aggregation. Useful for different DA layers(`keccak256` for calldata, nothing for validiums, chunk + KZG commiments for Ethereum blobs).

For more details about public inputs check implementation: [public_input.rs](../basic_system/src/system_implementation/system/public_input.rs)

## Messaging

### L2 -> L1 logs

Currently, there are 2 types of logs in the system:
- user messages
- l1 txs results

User messages are arbitrary bytes that can be sent to the settlement layer by users using the L1 Messenger system hook.
They should call the L1 Messenger address with calldata, which encodes `sendToL1(bytes)`.
And we implemented a system hook on this address, see [system hooks](system_hooks.md) for more details.

Also, we are sending information about each priority(l1) tx result, which includes its hash and status(execution success flag).

In the end, both these types converted to an `L2Log` structure.
Please note, that we are adding user messages separately to the pubdata, as `L2Log` contains only its hash.

For more details, see [the logs_storage implementation](zk_ee/src/common_structs/logs_storage.rs)

As mentioned above, during block aggregation we are building an l2 logs Merkle tree, so users can verify logs inclusion on the settlement layer.
This is going to be a fixed-size (16384) Merkle tree.

### L1 -> L2 transactions

Users can request L1 -> l2(priority) transactions on the settlement layer.
During block execution, the operator can provide any L1 -> L2 txs, but we'll calculate their hash and include it in the public input.
During block processing on the settlement layer, we'll verify that processed correct transactions using this hash.

L1 -> L2 txs validated and paid on the settlement layer, it's also possible to deposit base tokens using it.
See [transaction processing](bootloader/transaction_processing.md) for more details.

## Pubdata

Pubdata is the data we should publish with the chain DA, for rollups it should be Ethereum calldata or blobs.
Also, in the future, it can be a third-party DA solution such as Celestia, Avail, etc. Or validiums shouldn't post any data at all.

Pubdata includes data needed to restore the full chain state(everything under commitment mentioned in the public input section) and data for messaging.
Now it includes(for each block):
- block hash
- state diffs, for the current storage model it's:
  - compressed diffs for contracts storage slots changed during block execution
  - accounts changes(nonce, balance, bytecode)
- l2 -> l1 logs
- l2 -> l1 messages

Block number can be derived from pubdata implicitly, but you may note that it doesn't include block timestamp.
Currently, we are sending the last block timestamp to the settlement layer in calldata, but this part is not finalized and we may change it in the future.
Especially it's important for chains that settle on chains other than Ethereum.
